/* conf.c:      set up configuration information and static data */

#include <stdio.h>
#include <math.h>


#include "copyright.h"
#include "autoconf.h"

#include "mudconf.h"
#include "db.h"
#include "externs.h"
#include "interface.h"
#include "command.h"
#include "htab.h"
#include "alloc.h"
#include "flags.h"
#include "udb_defs.h"

/* ---------------------------------------------------------------------------
 * CONFPARM: Data used to find fields in CONFDATA.
 */

typedef struct confparm CONF;
struct confparm {
    char *pname;		/* parm name */
    int (*interpreter) ();	/* routine to interp parameter */
    int flags;			/* control flags */
    int *loc;			/* where to store value */
    long extra;			/* extra data for interpreter */
    int flags2;			/* Viewable flags */
    char *extrach;		/* Short description of param */
};

/* ---------------------------------------------------------------------------
 * External symbols.
 */

CONFDATA mudconf;
STATEDATA mudstate;

#ifndef STANDALONE
extern NAMETAB logdata_nametab[];
extern NAMETAB logoptions_nametab[];
extern NAMETAB access_nametab[];
extern NAMETAB attraccess_nametab[];
extern NAMETAB list_names[];
extern NAMETAB sigactions_nametab[];
extern CONF conftable[];
extern int	FDECL(flagstuff_internal, (char *, char *));
/* Lensy: Not external, but a forward declaration is needed */
CF_HAND(cf_dynstring);
#endif


/* ---------------------------------------------------------------------------
 * cf_init: Initialize mudconf to default values.
 */

void 
NDECL(cf_init)
{
#ifndef STANDALONE
    int i;
    strcpy(mudconf.roomlog_path, "roomlogs");
    strcpy(mudconf.data_dir, "./data");
    strcpy(mudconf.txt_dir, "./txt");
    strcpy(mudconf.indb, "netmush.db");
    strcpy(mudconf.outdb, "");
    strcpy(mudconf.crashdb, "");
    strcpy(mudconf.gdbm, "");
    mudconf.compress_db = 0;
    strcpy(mudconf.compress, "/usr/ucb/compress");
    strcpy(mudconf.uncompress, "/usr/ucb/zcat -c");
    strcpy(mudconf.status_file, "shutdown.status");
    mudconf.port = 6250;
    mudconf.html_port = 6251;
    mudconf.debug_id = 44660;
    mudconf.authenticate = 1;
    mudconf.init_size = 1000;
    mudconf.maildelete = 1;
    mudconf.player_dark = 1;
    mudconf.comm_dark = 0;
    mudconf.who_unfindable = 1;
    mudconf.who_default = 0;
    mudconf.start_build = 0;
    strcpy(mudconf.areg_file, "autoreg.txt");
    strcpy(mudconf.aregh_file, "areghost.txt");
    strcpy(mudconf.guest_file, "guest.txt");
    strcpy(mudconf.conn_file, "connect.txt");
    strcpy(mudconf.creg_file, "register.txt");
    strcpy(mudconf.regf_file, "create_reg.txt");
    strcpy(mudconf.motd_file, "motd.txt");
    strcpy(mudconf.wizmotd_file, "wizmotd.txt");
    strcpy(mudconf.quit_file, "quit.txt");
    strcpy(mudconf.down_file, "down.txt");
    strcpy(mudconf.full_file, "full.txt");
    strcpy(mudconf.site_file, "badsite.txt");
    strcpy(mudconf.crea_file, "newuser.txt");
    strcpy(mudconf.help_file, "help.txt");
#ifdef PLUSHELP
    strcpy(mudconf.plushelp_file, "plushelp.txt");
    strcpy(mudconf.plushelp_indx, "plushelp.indx");
#endif
    strcpy(mudconf.help_indx, "help.indx");
    strcpy(mudconf.news_file, "news.txt");
    strcpy(mudconf.news_indx, "news.indx");
    strcpy(mudconf.whelp_file, "wizhelp.txt");
    strcpy(mudconf.whelp_indx, "wizhelp.indx");
    strcpy(mudconf.error_file, "error.txt");
    strcpy(mudconf.error_indx, "error.indx");
    strcpy(mudconf.gconf_file, "noguest.txt");
    strcpy(mudconf.door_file, "doorconf.txt");
    strcpy(mudconf.door_indx, "doorconf.indx");
    strcpy(mudconf.manlog_file, "manual_log");
    strcpy(mudconf.mailinclude_file, "autoreg_include.txt");
    strcpy(mudconf.motd_msg, "");
    strcpy(mudconf.wizmotd_msg, "");
    strcpy(mudconf.downmotd_msg, "");
    strcpy(mudconf.fullmotd_msg, "");
    strcpy(mudconf.dump_msg, "");
    strcpy(mudconf.postdump_msg, "");
    strcpy(mudconf.spam_msg, "Spam: Spam security initiated. Command aborted.");
    strcpy(mudconf.spam_objmsg, "Spam: Spam security initiated. Your object's command aborted.");
    strcpy(mudconf.mailprog, "mail");
    strcpy(mudconf.guild_default, "Wanderer");
    strcpy(mudconf.guild_attrname, "guild");
    memset(mudconf.forbid_host, 0, sizeof(mudconf.forbid_host));
    memset(mudconf.suspect_host, 0, sizeof(mudconf.suspect_host));
    memset(mudconf.register_host, 0, sizeof(mudconf.register_host));
    memset(mudconf.noguest_host, 0, sizeof(mudconf.noguest_host));
    memset(mudconf.autoreg_host, 0, sizeof(mudconf.autoreg_host));
    memset(mudconf.validate_host, 0, sizeof(mudconf.validate_host));
    memset(mudconf.goodmail_host, 0, sizeof(mudconf.goodmail_host));
    memset(mudconf.nobroadcast_host, 0, sizeof(mudconf.nobroadcast_host));
    memset(mudconf.guest_namelist, 0, sizeof(mudconf.guest_namelist));
    memset(mudconf.log_command_list, 0, sizeof(mudconf.log_command_list));
    mudconf.mailsub = 1;
    mudconf.mailbox_size = 99;
    mudconf.mailmax_send = 100;
    mudconf.mailmax_fold = 20;
    mudconf.max_num_guests = 0;
    mudconf.name_spaces = 1;
    mudconf.fork_dump = 0;
    mudconf.fork_vfork = 0;
    mudconf.sig_action = SA_DFLT;
    mudconf.paranoid_alloc = 0;
    mudconf.max_players = -1;
    mudconf.max_size = -1;
    mudconf.whereis_notify = 1;
    mudconf.dump_interval = 3600;
    mudconf.check_interval = 600;
    mudconf.dump_offset = 0;
    mudconf.check_offset = 300;
    mudconf.idle_timeout = 3600;
    mudconf.conn_timeout = 120;
    mudconf.idle_interval = 60;
    mudconf.retry_limit = 3;
    mudconf.regtry_limit = 1;
    mudconf.output_limit = 16384;
    mudconf.paycheck = 0;
    mudconf.paystart = 0;
    mudconf.paylimit = 10000;
    mudconf.start_quota = 10;
    mudconf.payfind = 0;
    mudconf.digcost = 10;
    mudconf.linkcost = 1;
    mudconf.opencost = 1;
    mudconf.wall_cost = 250;
    mudconf.comcost = 5;
    mudconf.createmin = 10;
    mudconf.createmax = 505;
    mudconf.killmin = 10;
    mudconf.killmax = 100;
    mudconf.killguarantee = 100;
    mudconf.robotcost = 1000;
    mudconf.pagecost = 10;
    mudconf.searchcost = 100;
    mudconf.waitcost = 10;
    mudconf.machinecost = 64;
    mudconf.exit_quota = 1;
    mudconf.player_quota = 1;
    mudconf.room_quota = 1;
    mudconf.thing_quota = 1;
    mudconf.queuemax = 100;
    mudconf.wizqueuemax = 1000;
    mudconf.queue_chunk = 3;
    mudconf.active_q_chunk = 0;
    mudconf.sacfactor = 5;
    mudconf.sacadjust = -1;
    mudconf.use_hostname = 1;
    mudconf.recycle = 1;
    mudconf.quotas = 0;
    mudconf.ex_flags = 1;
    mudconf.examine_restrictive = 0;
    mudconf.robot_speak = 1;
    mudconf.clone_copy_cost = 0;
    mudconf.pub_flags = 1;
    mudconf.quiet_look = 1;
    mudconf.exam_public = 1;
    mudconf.read_rem_desc = 0;
    mudconf.read_rem_name = 0;
    mudconf.sweep_dark = 0;
    mudconf.player_listen = 0;
    mudconf.quiet_whisper = 1;
    mudconf.dark_sleepers = 1;
    mudconf.see_own_dark = 1;
    mudconf.idle_wiz_dark = 0;
    mudconf.pemit_players = 0;
    mudconf.pemit_any = 0;
    mudconf.match_mine = 0;
    mudconf.match_mine_pl = 0;
    mudconf.match_pl = 0;
    mudconf.switch_df_all = 1;
    mudconf.fascist_tport = 0;
    mudconf.terse_look = 1;
    mudconf.terse_contents = 1;
    mudconf.terse_exits = 1;
    mudconf.terse_movemsg = 1;
    mudconf.trace_topdown = 1;
    mudconf.trace_limit = 200;
    mudconf.safe_unowned = 0;
    mudconf.parent_control = 0;
    /* -- ??? Running SC on a non-SC DB may cause problems */
    mudconf.space_compress = 1;
    mudconf.intern_comp = 0;
    mudconf.start_room = 0;
    mudconf.start_home = -1;
    mudconf.default_home = -1;
    mudconf.master_room = -1;
    mudconf.switch_substitutions = 0;
    mudconf.sideeffects = 32;  /* Enable only list() by default */
    mudconf.sidefx_returnval = 0; /* sideeffects that create return dbref# if enabled */
    mudconf.safer_passwords = 0; /* If enabled, requires tougher to guess passwords */
    mudconf.sidefx_maxcalls = 1000; /* Maximum sideeffects allowed in a command */
    mudconf.max_percentsubs = 1000000; /* Maximum percent substitutions allowed in a command */
    mudconf.oattr_enable_altname = 0; /* Enable/Disable o-attr altnames */
    memset(mudconf.oattr_uses_altname, 0, sizeof(mudconf.oattr_uses_altname));
    strcpy(mudconf.oattr_uses_altname, "_NPC");
    mudconf.ahear_maxcount = 30;
    mudconf.ahear_maxtime = 0;
    mudconf.queue_compatible = 0;
    mudconf.lcon_checks_dark = 0; /* lcon/xcon check dark/unfindable */
    mudconf.mail_hidden = 0;	/* mail/anon hidden who is sent to */
    mudconf.enforce_unfindable = 0; /* Enforce unfindable for locate crap */
    mudstate.recurse_rlevel = 0;
    mudstate.nolookie = 1;
    mudstate.reality_notify = 0;
    mudstate.password_nochk = 0;
    mudstate.ahear_count = 0;
    mudstate.ahear_currtime = 0;
    mudstate.ahear_lastplr = -1;
    mudstate.chkcpu_toggle = 0;
    mudstate.chkcpu_locktog = 0;
    mudstate.sidefx_currcalls = 0; /* Counter for sideeffects called */
    mudstate.curr_percentsubs = 0; /* Counter for substitutions called */
    mudstate.cntr_reset = time(NULL);
    mudstate.tog_percentsubs = 0; /* Toggle disabler */
    mudstate.cntr_percentsubs = 0; /* Counter of 3, and then you die */
    mudstate.sidefx_toggle = 0; /* Toggle to show sidefx ceiling reached */
    mudstate.inside_locks = 0;	/* Toggle inside lock check */
    mudconf.max_sitecons = 50; /* Default maximum # of connects from this site */
    mudconf.must_unlquota = 0; /* Must @quota/unlock to give @quota */
    mudconf.partial_conn = 1; /* Enable/Disable @aconnects on partial connect */
    mudconf.partial_deconn = 0; /* Enable/Disable @adisconnects on partial disconnect */
    mudconf.global_parent_obj = -1; /* Generic Global Parent Object for Parenting attrs w/o @parent */
    mudconf.global_parent_room = -1; /* Room Global Parent Object for Parenting attrs w/o @parent */
    mudconf.global_parent_thing = -1; /* Thing Global Parent Object for Parenting attrs w/o @parent */
    mudconf.global_parent_player = -1; /* Player Global Parent Object for Parenting attrs w/o @parent */
    mudconf.global_parent_exit = -1; /* Exit Global Parent Object for Parenting attrs w/o @parent */
    mudconf.global_clone_obj = -1; /* Generic Global Clone for Attribute Cloning */
    mudconf.global_clone_room = -1; /* Room Global Clone for Attribute Cloning */
    mudconf.global_clone_thing = -1; /* Thing Global Clone for Attribute Cloning */
    mudconf.global_clone_player = -1; /* Player Global Clone for Attribute Cloning */
    mudconf.global_clone_exit = -1; /* Exit Global Clone for Attribute Cloning */
    mudconf.global_error_obj = -1; /* Global Error Object for all 'nonexisting' commands - @va */
    mudconf.global_attrdefault = -1; /* Global Attribute Handler for Locks */
    mudconf.zone_parents = 0;	/* Zones inherit attributes to it's children */
    mudconf.restrict_sidefx = 0;
    mudconf.formats_are_local = 0;
    mudconf.descs_are_local = 0;
    mudconf.noregist_onwho = 0;
    mudconf.nospam_connect = 0;
    mudconf.lnum_compat = 0;
    mudconf.nand_compat = 0;
    mudconf.hasattrp_compat = 0; /* Boolean: does hasattrp only check parents */
    mudconf.expand_goto = 0;	/* Expand exit movement to use 'goto' */
    mudconf.global_ansimask = 2097151; /* Always allow all ansi */
    mudconf.imm_nomod = 0; /* Immortal only with NOMODIFY */
    mudconf.paranoid_exit_linking = 0; /* Exit MUST be controlled to link */
    mudconf.notonerr_return = 1; /* If disabled, not() returns '0' for #-1 returns */
    mudconf.nonindxtxt_maxlines = 200; /* Max lines a nonindexed .txt file can have */
    mudconf.hackattr_nowiz = 0;	/* All _attrs defined to be wizard only */
    mudconf.hackattr_see = 0;	/* All _attrs defined to be viewable by wizard only */
    mudconf.penn_playercmds = 0; /* $cmds on players like PENN */
    mudconf.format_compatibility = 0; /* format attributes mux/penn compatible */
    mudconf.brace_compatibility = 0; /* MUX/TM3 brace {} compatibility with parser */
    mudconf.penn_switches = 0;  /* switch() and switchall() behave like PENN if '1' */
    mudconf.lattr_default_oldstyle = 0;	/* lattr() error's has errors snuffed */
    mudconf.look_moreflags = 0;	/* Show global flags on attributes */
    mudconf.hook_obj = -1;	/* Global HOOK object */
    mudconf.hook_cmd = 0;	/* Global HOOK cmd entry */
    mudconf.stack_limit = 10000; /* Stack limit on commands */
    mudconf.spam_limit = 60;	/* Stack limit of commands per minute */
    mudconf.mail_verbosity = 0;	/* Mail to disconnected players & subjects */
    mudconf.always_blind = 0;	/* BLIND flag always on by default */
    mudconf.empower_fulltel = 0; /* FULLTEL @power */
    mudconf.bcc_hidden = 1;   /* +BCC hides from target who mail is sent to */
    mudconf.exits_conn_rooms = 0; /* If true, then a floating room is one with no exits */
    /* Anonymous player for mail sending */
    strcpy(mudconf.mail_anonymous, "*Anonymous*");
    mudconf.secure_atruselock = 0; /* Global attruselock usage */
    mudconf.player_flags.word1 = 0;
    mudconf.player_flags.word2 = 0;
    mudconf.player_flags.word3 = 0;
    mudconf.player_flags.word4 = 0;
    mudconf.room_flags.word1 = 0;
    mudconf.room_flags.word2 = 0;
    mudconf.room_flags.word3 = 0;
    mudconf.room_flags.word4 = 0;
    mudconf.exit_flags.word1 = 0;
    mudconf.exit_flags.word2 = 0;
    mudconf.exit_flags.word3 = 0;
    mudconf.exit_flags.word4 = 0;
    mudconf.thing_flags.word1 = 0;
    mudconf.thing_flags.word2 = 0;
    mudconf.thing_flags.word3 = 0;
    mudconf.thing_flags.word4 = 0;
    mudconf.robot_flags.word1 = ROBOT;
    mudconf.robot_flags.word2 = 0;
    mudconf.robot_flags.word3 = 0;
    mudconf.robot_flags.word4 = 0;
    mudconf.player_toggles.word1 = 0;
    mudconf.player_toggles.word2 = 0;
    mudconf.player_toggles.word3 = 0;
    mudconf.player_toggles.word4 = 0;
    mudconf.player_toggles.word5 = 0;
    mudconf.player_toggles.word6 = 0;
    mudconf.player_toggles.word7 = 0;
    mudconf.player_toggles.word8 = 0;
    mudconf.room_toggles.word1 = 0;
    mudconf.room_toggles.word2 = 0;
    mudconf.room_toggles.word3 = 0;
    mudconf.room_toggles.word4 = 0;
    mudconf.room_toggles.word5 = 0;
    mudconf.room_toggles.word6 = 0;
    mudconf.room_toggles.word7 = 0;
    mudconf.room_toggles.word8 = 0;
    mudconf.exit_toggles.word1 = 0;
    mudconf.exit_toggles.word2 = 0;
    mudconf.exit_toggles.word3 = 0;
    mudconf.exit_toggles.word4 = 0;
    mudconf.exit_toggles.word5 = 0;
    mudconf.exit_toggles.word6 = 0;
    mudconf.exit_toggles.word7 = 0;
    mudconf.exit_toggles.word8 = 0;
    mudconf.thing_toggles.word1 = 0;
    mudconf.thing_toggles.word2 = 0;
    mudconf.thing_toggles.word3 = 0;
    mudconf.thing_toggles.word4 = 0;
    mudconf.thing_toggles.word5 = 0;
    mudconf.thing_toggles.word6 = 0;
    mudconf.thing_toggles.word7 = 0;
    mudconf.thing_toggles.word8 = 0;
    mudconf.robot_toggles.word1 = 0;
    mudconf.robot_toggles.word2 = 0;
    mudconf.robot_toggles.word3 = 0;
    mudconf.robot_toggles.word4 = 0;
    mudconf.robot_toggles.word5 = 0;
    mudconf.robot_toggles.word6 = 0;
    mudconf.robot_toggles.word7 = 0;
    mudconf.robot_toggles.word8 = 0;
    mudconf.vlimit = 750;
    mudconf.vattr_flags = AF_ODARK;
    mudconf.abort_on_bug = 0;
    mudconf.rwho_transmit = 0;
    strcpy(mudconf.muddb_name, "RhostMUSH");
    strcpy(mudconf.mud_name, "RhostMUSH");
    strcpy(mudconf.rwho_host, "139.78.1.15");	/* riemann.math.okstate.edu */
    strcpy(mudconf.rwho_pass, "get_your_own");
    mudconf.rwho_info_port = 6888;
    mudconf.rwho_data_port = 6889;
    mudconf.rwho_interval = 241;
    strcpy(mudconf.one_coin, "penny");
    strcpy(mudconf.many_coins, "pennies");
    mudconf.global_aconn = 0;
    mudconf.global_adconn = 0;
    mudconf.room_aconn = 0;
    mudconf.room_adconn = 0;
    mudconf.timeslice = 1000;
    mudconf.cmd_quota_max = 100;
    mudconf.cmd_quota_incr = 1;
    mudconf.control_flags = 0xffffffff;		/* Everything for now... */
    mudconf.log_options = LOG_ALWAYS | LOG_BUGS | LOG_SECURITY |
	LOG_NET | LOG_LOGIN | LOG_DBSAVES | LOG_CONFIGMODS |
	LOG_SHOUTS | LOG_STARTUP | LOG_WIZARD |
	LOG_PROBLEMS | LOG_PCREATES | LOG_MAIL | LOG_DOOR;
    mudconf.log_info = LOGOPT_TIMESTAMP | LOGOPT_LOC;
    mudconf.markdata[0] = 0x01;
    mudconf.markdata[1] = 0x02;
    mudconf.markdata[2] = 0x04;
    mudconf.markdata[3] = 0x08;
    mudconf.markdata[4] = 0x10;
    mudconf.markdata[5] = 0x20;
    mudconf.markdata[6] = 0x40;
    mudconf.markdata[7] = 0x80;
    mudconf.func_nest_lim = 50;
    mudconf.func_invk_lim = 2500;
    mudconf.wildmatch_lim = 100000;
    mudconf.ntfy_nest_lim = 20;
    mudconf.lock_nest_lim = 20;
    mudconf.parent_nest_lim = 10;
    mudconf.cache_trim = 0;
    mudconf.cache_depth = CACHE_DEPTH;
    mudconf.cache_width = CACHE_WIDTH;
    mudconf.cache_names = 1;
    mudconf.cache_steal_dirty = 0;
    mudconf.money_limit[0] = 0;
    mudconf.money_limit[1] = 500;
    mudconf.money_limit[2] = 2000;
    mudconf.money_limit[3] = 5000;
    mudconf.offline_reg = 0;
    mudconf.online_reg = 0;
    mudconf.areg_lim = 3;
    mudconf.whohost_size = 0;
    mudconf.who_showwiz = 0;
    mudconf.who_showwiztype = 0;
    mudconf.wiz_override = 1;
    mudconf.wiz_uselock = 1;
    mudconf.idle_wiz_cloak = 0;
    mudconf.idle_message = 1;
    mudconf.no_startup = 0;
    mudconf.newpass_god = 0;
    mudconf.who_wizlevel = 0;
    mudconf.allow_whodark = 1;
    mudconf.allow_ansinames = 15;
    mudconf.who_comment = 1;
    mudconf.safe_wipe = 0;
    mudconf.secure_jumpok = 0;
    mudconf.fmt_contents = 0;
    mudconf.fmt_exits = 0;
    mudconf.fmt_names = 0;
    mudconf.enable_tstamps = 0;
    mudconf.secure_dark = 0;
    mudconf.thing_parent = -1;
    mudconf.room_parent = -1;
    mudconf.exit_parent = -1;
    mudconf.player_parent = -1;
    mudconf.thing_defobj = -1;
    mudconf.room_defobj = -1;
    mudconf.exit_defobj = -1;
    mudconf.player_defobj = -1;
    mudconf.alt_inventories = 0;
    mudconf.altover_inv = 0;
    mudconf.showother_altinv = 0;
    mudconf.restrict_home = 0;
    mudconf.vattr_limit_checkwiz = 0; /* Wizard Vattr Limit Check Enabled? */
    mudconf.wizmax_vattr_limit = 1000000; /* Maximum new attributes wizard can make */
    mudconf.max_vattr_limit = 10000; /* Maximum new attributes player can make */
    mudconf.max_dest_limit = 1000; /* Maximum number of items player can @destroy */
    mudconf.wizmax_dest_limit = 100000; /* Maximum number of items player can @destroy */
    mudconf.hide_nospoof = 0;	/* Don't hide nospoof by default */
/* CPU information */
    /* Number of CPU slams allowed per dbref# in a row - default 3 */
    mudconf.max_cpu_cycles = 3;
    /* Level of security for CPU. 
     * 0 - standard (no limit per dbref)
     * 1 - auto-halt enactor
     * 2 - auto-halt enactor and set fubar
     * 3 - auto-halt enactor, set fubar, and set NOCONNECT and boot
     */
    mudconf.cpu_secure_lvl = 0;
    /* 80% cpu usage - range 50-100 */
    mudconf.cpuintervalchk = 80;
    /* One minute - range 60-3600 */
    mudconf.cputimechk = 60; 
/* End CPU information */
    /* Default mail object */
    mudconf.mail_def_object = -1;
    /* Enable '@' automatically for mail */
    mudconf.mail_tolist = 0;
    /* Default 'mail' to 'mail/quick' */
    mudconf.mail_default = 0;
    /* Player can log into program */
    mudconf.login_to_prog = 1;
    /* Player (minus immortal) can not shell from program */
    mudconf.noshell_prog = 0;
    /* Autodelete time for mail - default 21 days */
    mudconf.mail_autodeltime = 21;
    strcpy(mudconf.invname, "backpack");
    mudconf.secure_functions = 0;
    mudconf.heavy_cpu_max = 50;	/* Max cycles of a heavy-used cpu-intensive
                                 * function per command 
                                 */
    /* Connection security level */
    mudstate.cmp_lastsite = -1;
    mudstate.cmp_lastsite_cnt = 0;
    mudconf.lastsite_paranoia = 0; /* 0-off, 1-register, 2-forbid */
    mudconf.pcreate_paranoia = 0; /* 0-off, 1-register, 2-forbid */
    mudconf.max_lastsite_cnt = 20;	/* Shouldn't connect more than 20 times in X period */
    mudconf.min_con_attempt = 60;	/* 60 seconds default */
    mudstate.last_con_attempt = 0;
    mudconf.max_pcreate_lim = -1;
    mudconf.max_pcreate_time = 60;
    mudstate.last_pcreate_time = 0;
    mudstate.last_pcreate_cnt = 0;
    mudstate.reverse_wild = 0;
    mudstate.stack_val = 0;
    mudstate.stack_toggle = 0;
    mudstate.stack_cntr = 0;
    mudstate.train_cntr = 0;

#ifdef REALITY_LEVELS
    mudconf.no_levels = 0;
    mudconf.wiz_always_real = 0;
    mudconf.reality_locks = 0; /* @Lock/user used as Reality Lock? */
    mudconf.reality_locktype = 0; /* Type of lock */
    mudconf.def_room_rx = 1;
    mudconf.def_room_tx = ~(RLEVEL)0;
    mudconf.def_player_rx = 1;
    mudconf.def_player_tx = 1;
    mudconf.def_exit_rx = 1;
    mudconf.def_exit_tx = 1;
    mudconf.def_thing_rx = 1;
    mudconf.def_thing_tx = 1;
#endif /* REALITY_LEVELS */

    memset(mudstate.last_command, 0, sizeof(mudstate.last_command));
    mudstate.new_vattr = 0;
    mudstate.last_cmd_timestamp = 0;
    mudstate.heavy_cpu_recurse = 0;
    mudstate.max_logins_allowed = 0;
    mudstate.iter_inum = -1;
    /* Current CPU slam level */
    mudstate.curr_cpu_cycle=0;
    /* Last dbref# to CPU-SLAM */
    mudstate.curr_cpu_user=NOTHING;
    mudstate.last_cpu_user=NOTHING;
    mudstate.force_halt = 0;
    mudstate.autoreg = 0;
    mudstate.initializing = 0;
    mudstate.panicking = 0;
    mudstate.logging = 0;
    mudstate.epoch = 0;
    mudstate.generation = 0;
    mudstate.curr_player = NOTHING;
    mudstate.curr_enactor = NOTHING;
    mudstate.curr_cmd = (char *) "< none >";
    mudstate.shutdown_flag = 0;
    mudstate.reboot_flag = 0;
    mudstate.rwho_on = 0;
    mudstate.attr_next = A_USER_START;
    mudstate.debug_cmd = (char *) "< init >";
    strcpy(mudstate.doing_hdr, "Doing");
    strcpy(mudstate.ng_doing_hdr, "Doing");
    strcpy(mudstate.guild_hdr, "Guild");
    mudstate.access_list = NULL;
    mudstate.suspect_list = NULL;
    mudstate.special_list = NULL;
    mudstate.qfirst = NULL;
    mudstate.qlast = NULL;
    mudstate.qlfirst = NULL;
    mudstate.qllast = NULL;
    mudstate.qwait = NULL;
    mudstate.qsemfirst = NULL;
    mudstate.qsemlast = NULL;
    mudstate.fqwait = NULL;
    mudstate.fqsemfirst = NULL;
    mudstate.fqsemlast = NULL;
    mudstate.badname_head = NULL;
    mudstate.lbuf_buffer = NULL;
    mudstate.mstat_ixrss[0] = 0;
    mudstate.mstat_ixrss[1] = 0;
    mudstate.mstat_idrss[0] = 0;
    mudstate.mstat_idrss[1] = 0;
    mudstate.mstat_isrss[0] = 0;
    mudstate.mstat_isrss[1] = 0;
    mudstate.mstat_secs[0] = 0;
    mudstate.mstat_secs[1] = 0;
    mudstate.mstat_curr = 0;
    mudstate.iter_alist.data = NULL;
    mudstate.iter_alist.len = 0;
    mudstate.iter_alist.next = NULL;
    mudstate.mod_alist = NULL;
    mudstate.mod_size = 0;
    mudstate.mod_al_id = NOTHING;
    mudstate.min_size = 0;
    mudstate.db_top = 0;
    mudstate.db_size = 0;
    mudstate.freelist = NOTHING;
    mudstate.markbits = NULL;
    mudstate.func_nest_lev = 0;
    mudstate.ufunc_nest_lev = 0;
    mudstate.func_invk_ctr = 0;
    mudstate.ntfy_nest_lev = 0;
    mudstate.lock_nest_lev = 0;
    mudstate.whisper_state = 0;
    mudstate.nowall_over = 0;
    mudstate.eval_rec = 0;
    for (i = 0; i < MAX_GLOBAL_REGS; i++)
	mudstate.global_regs[i] = NULL;
#ifdef EXPANDED_QREGS
    strcpy(mudstate.nameofqreg, "0123456789abcdefghijklmnopqrstuvwxyz");
    mudstate.nameofqreg[36]='\0';
#endif
    mudstate.emit_substitute = 0; /* Toggle @emit/substitute */
#else
    mudconf.paylimit = 10000;
    mudconf.digcost = 10;
    mudconf.opencost = 1;
    mudconf.robotcost = 1000;
    mudconf.createmin = 5;
    mudconf.createmax = 505;
    mudconf.sacfactor = 5;
    mudconf.sacadjust = -1;
    mudconf.room_quota = 1;
    mudconf.exit_quota = 1;
    mudconf.thing_quota = 1;
    mudconf.player_quota = 1;
    mudconf.quotas = 0;
    mudconf.start_room = 0;
    mudconf.start_home = -1;
    mudconf.default_home = -1;
    mudconf.vattr_flags = AF_ODARK;
    mudconf.log_options = 0xffffffff;
    mudconf.log_info = 0;
    mudconf.markdata[0] = 0x01;
    mudconf.markdata[1] = 0x02;
    mudconf.markdata[2] = 0x04;
    mudconf.markdata[3] = 0x08;
    mudconf.markdata[4] = 0x10;
    mudconf.markdata[5] = 0x20;
    mudconf.markdata[6] = 0x40;
    mudconf.markdata[7] = 0x80;
    mudconf.ntfy_nest_lim = 20;
    mudconf.cache_trim = 0;
    mudconf.cache_steal_dirty = 1;
    mudconf.vlimit = 750;
    mudconf.safer_passwords = 0; /* If enabled, requires tougher to guess passwords */
    mudconf.vattr_limit_checkwiz = 0; /* Check if wizards check vattr limits */
    mudstate.logging = 0;
    mudstate.attr_next = A_USER_START;
    mudstate.iter_alist.data = NULL;
    mudstate.iter_alist.len = 0;
    mudstate.iter_alist.next = NULL;
    mudstate.mod_alist = NULL;
    mudstate.mod_size = 0;
    mudstate.mod_al_id = NOTHING;
    mudstate.min_size = 0;
    mudstate.db_top = 0;
    mudstate.db_size = 0;
    mudstate.freelist = NOTHING;
    mudstate.markbits = NULL;
#endif /* STANDALONE */
}


#ifndef STANDALONE

static int
countwordsnew(char *str)
{
    int n;

/* Trim starting white space */
    n = 0;
    while (*str && isspace((int)*str))
       str++;
/* Count words */
    while ( *str ) {
       while (*str && !isspace((int)*str))
          str++;
       n++;
       while (*str && isspace((int)*str))
          str++;
    }
    return n;
}

/* ---------------------------------------------------------------------------
 * cf_log_notfound: Log a 'parameter not found' error.
 */

void 
cf_log_notfound(dbref player, char *cmd, const char *thingname,
		char *thing)
{
    char *buff;

    /* Modified this so buffers are cut off on unrecognized commands */
    if (mudstate.initializing) {
	STARTLOG(LOG_STARTUP, "CNF", "NFND")
	    buff = alloc_lbuf("cf_log_notfound.LOG");
	sprintf(buff, "%.150s: %.1900s %.1900s not found",
		cmd, thingname, thing);
	log_text(buff);
	free_lbuf(buff);
	ENDLOG
    } else {
	buff = alloc_lbuf("cf_log_notfound");
	sprintf(buff, "%.1900s %.1900s not found", thingname, thing);
	notify(player, buff);
	free_lbuf(buff);
    }
}

/* ---------------------------------------------------------------------------
 * cf_log_syntax: Log a syntax error.
 */

void 
cf_log_syntax(dbref player, char *cmd, const char *template, char *arg)
{
    char *buff;

    if (mudstate.initializing) {
	STARTLOG(LOG_STARTUP, "CNF", "SYNTX")
	    buff = alloc_lbuf("cf_log_syntax.LOG");
	sprintf(buff, template, arg);
	log_text(cmd);
	log_text((char *) ": ");
	log_text(buff);
	free_lbuf(buff);
	ENDLOG
    } else {
	buff = alloc_lbuf("cf_log_syntax");
	sprintf(buff, template, arg);
	notify(player, buff);
	free_lbuf(buff);
    }
}

/* ---------------------------------------------------------------------------
 * cf_status_from_succfail: Return command status from succ and fail info
 */

int 
cf_status_from_succfail(dbref player, char *cmd, int success, int failure)
{
    char *buff;

    /* If any successes, return SUCCESS(0) if no failures or
       PARTIAL_SUCCESS(1) if any failures. */

    if (success > 0)
	return ((failure == 0) ? 0 : 1);

    /* No successes.  If no failures indicate nothing done.
       Always return FAILURE(-1) */

    if (failure == 0) {
	if (mudstate.initializing) {
	    STARTLOG(LOG_STARTUP, "CNF", "NDATA")
		buff = alloc_lbuf("cf_status_from_succfail.LOG");
	    sprintf(buff, "%.3900s: Nothing to set", cmd);
	    log_text(buff);
	    free_lbuf(buff);
	    ENDLOG
	} else {
	    notify(player, "Nothing to set");
	}
    }
    return -1;
}

#ifdef REALITY_LEVELS
/* ---------------------------------------------------------------------------
 * cf_rlevel: Set reality level
 */
CF_HAND(cf_rlevel)
{
    CONFDATA *mc = (CONFDATA *)vp;
    int i, j, k, cmp_x, cmp_y, cmp_z;
    char dup1[9], dup2[9], *nptr, tbufit[20];
 
    cmp_z = countwordsnew(str);
    if ( (cmp_z < 2) || (cmp_z > 3) ) {
	STARTLOG(LOG_STARTUP, "CNF", "LEVEL")
        log_text("Too many arguments for reality_level. 2 to 3 expected, ");
        sprintf(tbufit, "%d", cmp_z);
        log_text(tbufit);
        log_text(" found.\r\n              -->String in question: ");
        log_text(str);
        ENDLOG
        return 1;
    }
    if(mc->no_levels >= 32) {
	STARTLOG(LOG_STARTUP, "CNF", "LEVEL")
        log_text("Too many levels defined. 32 maximum allowed.");
        ENDLOG
        return 1;
    }

    for(i=0; *str && ((*str != ' ') && (*str != '\t')) && (i < 8); ++str) {
        if(i < 8) {
            dup1[i] = tolower(*str);
            mc->reality_level[mc->no_levels].name[i++] = *str;
        }
    }
    dup1[i] = '\0';

    cmp_x = sizeof(mudconf.reality_level);
    cmp_y = sizeof(mudconf.reality_level[0]);
    if ( cmp_y == 0 )
       cmp_z = 0;
    else
       cmp_z = cmp_x / cmp_y;
    for (k = 0; (k < mudconf.no_levels) && (k < cmp_z); ++k) {
      nptr = mudconf.reality_level[k].name;
      j=0;
      while (*nptr) {
        dup2[j++] = tolower(*nptr);
        nptr++;
      }
      dup2[j] = '\0';
      if ( strcmp(dup1, dup2) == 0 ) {
	 STARTLOG(LOG_STARTUP, "CNF", "LEVEL")
         log_text("Duplicate RLEVEL name: ");
         log_text(mudconf.reality_level[mc->no_levels].name);
         ENDLOG
         mudconf.reality_level[mc->no_levels].name[0] = '\0';
         return 0;
      }
    }

    /* If name is over 8 chars, trim off the rest */
    if ( *str && ((*str != ' ') && (*str != '\t')) )
       for(; *str && ((*str != ' ') && (*str != '\t')); ++str);

    mc->reality_level[mc->no_levels].name[i] = '\0';
    mc->reality_level[mc->no_levels].value = 1;
    strcpy(mc->reality_level[mc->no_levels].attr, "DESC");
    for(; *str && (*str == ' ' || *str == '\t'); ++str);
    for(i=0; *str && isdigit((int)*str); ++str)
        i = i * 10 + (*str - '0');
    if(i)
        mc->reality_level[mc->no_levels].value = (RLEVEL) i;
    for(; *str && ((*str == ' ') || (*str == '\t')); ++str);
    if(*str) {
        strncpy(mc->reality_level[mc->no_levels].attr, str, 32);
        mc->reality_level[mc->no_levels].attr[32] = '\0';
    }
    mc->no_levels++;
    return 0;
}
#endif /* REALITY_LEVELS */

/* ---------------------------------------------------------------------------
 * cf_int: Set integer parameter.
 */

CF_HAND(cf_int)
{
    /* Copy the numeric value to the parameter */
    
  if (sscanf(str, "%d", vp)) {
    return 0;
  } else {
    if (*str == '#') {
      if (player >= 0) {
	notify(player, tprintf("'%s' is not a valid integer. Maybe try without the '#'?",str));
      } else {
	STARTLOG(LOG_CONFIGMODS, "CFG", "ERR")
	  log_name(player);
	  log_text(str);
          log_text("is not valid. Maybe try without the '#'?");
	ENDLOG;
      }      
    }
    return -1;
  }
}
CF_HAND(cf_int_runtime)
{
   /* Copy the numeric value to the parameter but ONLY on startup */
    if (mudstate.initializing) {
       sscanf(str, "%d", vp);
       return 0;
    }
    else
       return -1;
}

CF_HAND(cf_vint)
{
    sscanf(str, "%d", vp);
    if ((*vp < 0) || (*vp > 10000))
	return -1;
    else
	return 0;
}

CF_HAND(cf_mailint)
{
    sscanf(str, "%d", vp);
    if ((*vp < 10) || (*vp > 9999))
	return -1;
    else
	return 0;
}

/* ---------------------------------------------------------------------------
 * cf_sidefx: Set up sidefx flags.
 */

#define MUXMASK   131135
#define PENNMASK  458719
#define ALLMASK   2147483647

/* Inverse of above function */
const char * sideEffects[] = {
  "SET" , "CREATE", "LINK", "PEMIT", "TEL", "LIST", "DIG", "OPEN", "EMIT",
  "OEMIT", "CLONE", "PARENT", "LOCK", "LEMIT", "REMIT", "WIPE", "DESTROY",
  "ZEMIT", "NAME", "TOGGLE", "TXLEVEL", "RXLEVEL", "RSET", "MOVE", NULL
};

void sideEffectMaskToString(int mask, char *buff, char **bufc) {
   int bFirst = 0;
   int i;
   *buff = '\0';

   /* Go through each sideeffect, seeing if it's defined
    * in the given mask
    */
   for (i = 0 ; sideEffects[i] != NULL ; i++) {
      if (mask & (int) pow(2.0, (double) i)) {
         if (bFirst) {
            safe_chr(' ', buff, bufc);
         }
         safe_str((char *) sideEffects[i], buff, bufc);
         bFirst++;
      }
   }
}

/* Main config function for sideeffects.. has to be smart as users may expect
 * it to handle integers still!
 */
CF_HAND(cf_sidefx) {
   int mask = 0;
   int i, nErr = 0;
   char *ptr;
   
   ptr = str;

   if (str == NULL || *str == '\0') {
       return 0;
   }

   *vp = 0;

   // Oh crap - must be an old-style definition
   if (*str >= '0' && *str <= '9') {
     char *ptr, *eosptr;
     int retval;
     retval = cf_int(vp, str, extra, player, cmd);
     eosptr = ptr = alloc_lbuf("cf_sidefx");
     *eosptr = '\0';

     sideEffectMaskToString(*vp, ptr, &eosptr);
     if (player > 0) {
       notify(player, tprintf("Sideeffects set to %s", ptr));
     } else {
       STARTLOG(LOG_CONFIGMODS, "CFG", "INF")
         log_text("Sideeffects set to ");
	 log_text(ptr);
       ENDLOG;
     } 
     free_lbuf(ptr);
     return retval;
   }

   // Make sure we have a capitalized string
   while (*ptr != '\0') {
     *ptr = toupper(*ptr);
     ptr++;
   }

   // Check for built in short cuts.
   if (strcmp("PENN", str) == 0) {
     *vp = PENNMASK;
   } else if (strcmp("MUX", str) == 0) {
     *vp = MUXMASK;
   } else if (strcmp("ALL", str) == 0) {
     *vp = ALLMASK;
   } else if (strcmp("NONE", str) == 0) {
     *vp = 0;
   } else {   
     // Right, wasn't shortcut - time for the long way around.
     ptr = strtok(str, " ");
     while (ptr) {
       for (i = 0 ; sideEffects[i] != NULL ; i++) {
	 if (strcmp(ptr, sideEffects[i]) == 0) {
           mask |= (int) pow(2.0, (double) i);
	   break;
	 }
       }
       
       if (sideEffects[i] == NULL) {
	 nErr++;
	 if (player >= 0) {
	   notify(player, tprintf("%s is not a valid sideeffect.", ptr));
	 } else {
	   STARTLOG(LOG_CONFIGMODS, "CFG", "ERR")
   	     log_text(str);
	     log_text("is not a valid sideeffect.");
	   ENDLOG;
	 }
       }
       ptr = strtok(NULL, " ");
     }
     *vp = mask;
   }
   return (nErr > 0) ? 1 : 0;
}


/* ---------------------------------------------------------------------------
 * cf_bool: Set boolean parameter.
 */

NAMETAB hook_names[] =
{
    {(char *) "before", 3, 0, 1},
    {(char *) "after", 3, 0, 2},
    {(char *) "permit", 3, 0, 4},
    {(char *) "ignore", 3, 0, 8},
    {(char *) "bfail", 3, 0, 16},
    {(char *) "afail", 3, 0, 32},
    {NULL, 0, 0, 0}};

CF_HAND(cf_hook)
{
    char *hookcmd, *hookptr, playbuff[201];
    int hookflg, retval;
    CMDENT *cmdp;

    retval = -1;
    memset(playbuff, 0, sizeof(playbuff));
    strncpy(playbuff, str, 200);
    hookcmd = strtok(playbuff, " \t");
    if ( hookcmd != NULL )
       cmdp = (CMDENT *)hashfind(hookcmd, &mudstate.command_htab);
    else
       return retval;
    if ( !cmdp )
       return retval;

    *vp = cmdp->hookmask;
    strncpy(playbuff, str, 200);
    hookptr = strtok(NULL, " \t");
    while ( hookptr != NULL ) {
       if ( *hookptr == '!' && *(hookptr+1)) {
          hookflg = search_nametab(GOD, hook_names, hookptr+1);
          if ( hookflg != -1 ) {
             retval = 0;
             *vp = *vp & ~hookflg;
          }
       } else {
          hookflg = search_nametab(GOD, hook_names, hookptr);
          if ( hookflg != -1 ) {
             retval = 0;
             *vp = *vp | hookflg;
          }
       }
       hookptr = strtok(NULL, " \t");
    }
    cmdp->hookmask = *vp;
    return retval;
}

NAMETAB bool_names[] =
{
    {(char *) "true", 1, 0, 1},
    {(char *) "false", 1, 0, 0},
    {(char *) "yes", 1, 0, 1},
    {(char *) "no", 1, 0, 0},
    {(char *) "1", 1, 0, 1},
    {(char *) "0", 1, 0, 0},
    {NULL, 0, 0, 0}};

CF_HAND(cf_bool)
{
    *vp = search_nametab(GOD, bool_names, str);
    if (*vp == -1)
	*vp = 0;
    return 0;
}

CF_HAND(cf_who_bool)
{
  int prev, ret;
  DESC *d;

  prev = *vp;
  ret = cf_bool(vp, str, extra, player, cmd);
  if (prev && !ret) {
    DESC_ITER_CONN(d) {
      strncpy(d->doing,strip_ansi(d->doing),DOING_SIZE);
      *(d->doing + DOING_SIZE) = '\0';
    }
  }
  return ret;
}

/* ---------------------------------------------------------------------------
 * cf_option: Select one option from many choices.
 */

CF_HAND(cf_option)
{
    int i;

    i = search_nametab(GOD, (NAMETAB *) extra, str);
    if (i == -1) {
	cf_log_notfound(player, cmd, "Value", str);
	return -1;
    }
    *vp = i;
    return 0;
}

/* ---------------------------------------------------------------------------
 * cf_dynguest: Set dynamic guests then call dynstring function
 */
CF_HAND(cf_dynguest)
{
   DESC *d;
   char tplayer[6], playbuff[1001], *tplaybuff;
   char *inbufa, *inbufaptr;
   char *inbufb, *inbufbptr;
   int noret_val, first, not;
   dbref lupp;

   if ( str == NULL || (strcmp(str, " ") == 0)) {
      if ( Good_obj(player) )
         notify(player, "Entry not changed.");
      return -1;
   }

   noret_val = 0;

   /* On initialization, lookup_player() doesn't work */
   if (mudstate.initializing) {
      memset(playbuff, 0, sizeof(playbuff));
      strncpy(playbuff, str, 1000);
      tplaybuff = strtok(playbuff, " \t");
      inbufaptr = inbufa = alloc_lbuf("dynguest.initialize");
      while (tplaybuff != NULL ) {
         first = 0;
         first = atoi(tplaybuff);
         /* We can only do minimal checking here because
          * No database is currently loaded to check against 
          */
         if ( first <= 0 ) {
            noret_val = -1;
            break;
         }
         safe_str(tprintf("#%s ", tplaybuff), inbufa, &inbufaptr);
         tplaybuff = strtok(NULL, " \t");
      }
      if ( noret_val == -1 ) {
         memset(playbuff, 0, sizeof(playbuff));
	 STARTLOG(LOG_STARTUP, "CNF", "DYNGUEST")
	 sprintf(playbuff, "Invalid player list '%.900s' for paramater '%s'.", str, cmd);
	 log_text(playbuff);
	 ENDLOG
      } else {
         noret_val = cf_dynstring(vp, inbufa, extra, player, cmd); 
      }
      free_lbuf(inbufa);
      return noret_val;
   }

   DESC_ITER_CONN(d) { 
      memset(tplayer, 0, sizeof(tplayer));
      strncpy(tplayer, Name(d->player), 5);
      if ( stricmp(tplayer, "guest") == 0 ) {
         noret_val = 1;
         break;
      }
      memset(playbuff, 0, sizeof(playbuff));
      strncpy(playbuff, mudconf.guest_namelist, 1000);
      tplaybuff = strtok(playbuff, " \t");
      while (tplaybuff != NULL ) {
         lupp = lookup_player(NOTHING, tplaybuff, 0);
         if ( lupp == d->player ) {
            noret_val = 1;
            break;
         }
         tplaybuff = strtok(NULL, " \t");
      }
      if (noret_val == 1)
         break;
      memset(playbuff, 0, sizeof(playbuff));
      strncpy(playbuff, str, 1000);
      tplaybuff = strtok(playbuff, " \t");
      while (tplaybuff != NULL ) {
         lupp = lookup_player(NOTHING, tplaybuff, 0);
         if ( (lupp < 0) && (*tplaybuff != '!') ) {
            noret_val = 4;
            break;
         }
         if ( lupp == d->player ) {
            noret_val = 2;
            break;
         }
         tplaybuff = strtok(NULL, " \t");
      }
      if ( noret_val > 0 )
         break;
   }
   if ( noret_val == 1 ) {
      notify_quiet(player, "Can not change value while pre-defined guests connected.");
      return (-1);
   } else if ( noret_val == 2 ) {
      notify_quiet(player, "Can not change value while a target player connected.");
      return (-1);
   } else if ( noret_val == 4 ) {
      notify_quiet(player, "Can not add non-players to the list.");
      return (-1);
   }
   /* Ok, now let's check for matching strings */
   inbufaptr = inbufa = alloc_lbuf("dynguest.1");
   memset(playbuff, 0, sizeof(playbuff));
   strncpy(playbuff, mudconf.guest_namelist, 1000);
   tplaybuff = strtok(playbuff, " \t");
   safe_chr(' ', inbufa, &inbufaptr);
   while ( tplaybuff != NULL ) {
      lupp = lookup_player(NOTHING, tplaybuff, 0);
      safe_str(tprintf("%d ", lupp), inbufa, &inbufaptr); 
      tplaybuff = strtok(NULL, " \t");
   }
   inbufbptr = inbufb = alloc_lbuf("dynguest.2");
   memset(playbuff, 0, sizeof(playbuff));
   strncpy(playbuff, str, 1000);
   tplaybuff = strtok(playbuff, " \t");
   first = 0;
   while ( tplaybuff != NULL ) {
      if (first)
         safe_chr(' ', inbufb, &inbufbptr);
      if ( *tplaybuff == '!' ) {
         lupp = lookup_player(NOTHING, tplaybuff+1, 0);
         not = 1;
      } else {
         lupp = lookup_player(NOTHING, tplaybuff, 0);
         not = 0;
      }
      if ( Good_obj(lupp) ) {
         if ( not ) {
            safe_str(tprintf("!#%d", lupp), inbufb, &inbufbptr);
         } else
            safe_str(tprintf("#%d", lupp), inbufb, &inbufbptr);
      } else {
         safe_str(tplaybuff, inbufb, &inbufbptr);
         /* Verification on startup can't be done.  Player hash not loaded */
         if ( !not ) {
            noret_val = 2;
            break;
         }
      }
      if ( (strstr(inbufa, tprintf(" %d ", lupp)) != NULL) && !not ) {
         noret_val = 3;
         break;
      }
      tplaybuff = strtok(NULL, " \t");
      first = 1;
   }
   free_lbuf(inbufa);
   if ( noret_val == 3 ) {
      notify_quiet(player, "Can not add duplicated entry.");
      free_lbuf(inbufb);
      return (-1);
   } else if (noret_val == 2) {
      notify_quiet(player, "Can not add non-players to the list.");
      free_lbuf(inbufb);
      return (-1);
   } else {
        noret_val = cf_dynstring(vp, inbufb, extra, player, cmd); 
        free_lbuf(inbufb);
        return noret_val;
   }
}

/* ---------------------------------------------------------------------------
 * cf_dynstring: Set dynamic growth string parameter.
 */
CF_HAND(cf_dynstring)
{
   int retval, chkval, addval, first, second, third;
   char *buff, *tbuff, *buff2, *tbuff2, *stkbuff, *abuf1, *abuf2, *abuf3, *tabuf2, *tabuf3;
   char quick_buff[1002];

   chkval = retval = addval = 0;
   if ( strcmp( str, "!ALL" ) == 0 ) {
      notify(player, "Entry purged.");
      strcpy((char *) vp, "");
      chkval = 1;
   } else {
      abuf1 = alloc_lbuf("cf_dynstring.BUF1");
      tabuf2 = abuf2 = alloc_lbuf("cf_dynstring.BUF2");
      tabuf3 = abuf3 = alloc_lbuf("cf_dynstring.BUF3");
      strcpy(abuf1, str);
      stkbuff = strtok(abuf1, " ");
      second = 0;
      third = 0;
      addval = 0;
      while (stkbuff) {
         if (*stkbuff == '!') {
            if ( second )
               safe_chr(' ', abuf2, &tabuf2);
            safe_str(stkbuff+1, abuf2, &tabuf2);
            second = 1;
         } else {
            if ( third )
               safe_chr(' ', abuf3, &tabuf3);
            safe_str(stkbuff, abuf3, &tabuf3);
            third = 1;
            addval++;
         }
         stkbuff = strtok(NULL," ");
      }
      strcpy(abuf1, (char *) vp);
      stkbuff = strtok(abuf1, " ");
      chkval = 0;
      first = 0;
      tbuff2 = buff2 = alloc_lbuf("cf_dynstring.ALLOC2");
      while (stkbuff) {
         /* This is always 2 chars above max length stkbuff can be */
         memset(quick_buff, 0, sizeof(quick_buff));
         sprintf(quick_buff, "*%s*", stkbuff);
         if (!quick_wild(quick_buff,abuf2)) {
            if ( first )
               safe_chr(' ', buff2, &tbuff2);
            safe_str(stkbuff, buff2, &tbuff2);
            first = 1;
         } else {
            chkval++;
         }
         stkbuff = strtok(NULL," ");
      }
      free_lbuf(abuf2);
      tbuff = buff = alloc_lbuf("cf_dynstring.ALLOC");
      safe_str(buff2, buff, &tbuff);
      if ( buff2 )
         safe_chr(' ', buff, &tbuff);
      free_lbuf(buff2);
      stkbuff = strtok(abuf3, " ");
      first = 0;
      second = 0;
      while ( stkbuff ) {
         if ( (strlen(buff) + strlen(stkbuff) + 1) < extra ) {
            safe_str(stkbuff, buff, &tbuff);
            safe_chr(' ', buff, &tbuff);
            first++;
         }
         second++;
         stkbuff = strtok(NULL, " ");
      }
      free_lbuf(abuf3);
      strncpy((char *) vp, buff, (extra - 1));
      free_lbuf(abuf1);
      free_lbuf(buff);
      if ( first != second ) {
         if ( chkval && first )
            notify(player, tprintf("String exceeded maximum length.  %d removed, %d added, %d ignored.",
                   chkval, first, second - first));
         else if ( chkval )
            notify(player, "String exceeded maximum length.");
         else
            notify(player, tprintf("String exceeded maximum length.  %d added, %d ignored.",
                   first, second - first));
	 STARTLOG(LOG_STARTUP, "CNF", "NFND")
            buff = alloc_lbuf("cf_string.LOG");
	    sprintf(buff, "%s: String buffer exceeded - truncated", cmd);
	    log_text(buff);
	    free_lbuf(buff);
	 ENDLOG
         retval = 1;
      } else { 
         if ( !chkval && !addval )
            notify(player, "Entry not changed.");
         else
            if ( chkval && first )
               notify(player, tprintf("Entry updated.  %d removed, %d added.", chkval, first));
            else if ( chkval )
               notify(player, tprintf("Entry updated.  %d removed.", chkval));
            else
               notify(player, tprintf("Entry updated.  %d added.", first));
      }
   }
   if ( !chkval && !addval  )
      retval = -1;
   return retval;
}

/* ---------------------------------------------------------------------------
 * cf_string: Set string parameter.
 */

CF_HAND(cf_string)
{
    int retval;
    char *buff;

    /* Copy the string to the buffer if it is not too big */

    retval = 0;
    if (strlen(str) >= extra) {
	str[extra - 1] = '\0';
	if (mudstate.initializing) {
	    STARTLOG(LOG_STARTUP, "CNF", "NFND")
		buff = alloc_lbuf("cf_string.LOG");
	    sprintf(buff, "%.3900s: String truncated", cmd);
	    log_text(buff);
	    free_lbuf(buff);
	    ENDLOG
	} else {
	    notify(player, "String truncated");
	}
	retval = 1;
    }
    strcpy((char *) vp, str);
    return retval;
}

/* ---------------------------------------------------------------------------
 * cf_alias: define a generic hash table alias.
 */

int validate_aliases(dbref player,
		     HASHTAB *htab, 
		     char *orig, char *alias,
		     char *label, char *cmd) {
  int *cmdp = NULL, *aliasp = NULL, retval;

  if (!orig || !*orig) {
    cf_log_syntax(player, cmd, "Don't know what to alias.", "");
    return -1;
  }

  if (!alias || !*alias) {
    /* Not much we can do here in a generic fashion.. */
    ;
  }
  else if (strcmp("!", orig) == 0) {
    /* We want to remove the alias 
     * - orig is assumed to be the alias 
     */
    aliasp = hashfind(alias, htab);
    if (!aliasp) {
      cf_log_syntax(player, cmd, "Error: '%s' is not a valid alias.", alias);
      retval = -1;
    } else if (htab->last_entry->bIsOriginal == 1) {
      cf_log_syntax(player, cmd, "Error: '%s' is not an alias, cannot delete.", alias);
      retval = -1;
    } else {
      cf_log_syntax(player, cmd, "Warning: Alias '%s' deleted.", alias);
      hashdelete(alias, htab);
      retval = 1;
    }
  } else {
    cmdp = hashfind(orig, htab);
    if (cmdp == NULL) {
      cf_log_notfound(player, cmd, label, orig);
      retval = -1;
    }
    aliasp = hashfind(alias, htab);
    if (aliasp == NULL) {
      retval = hashadd2(alias, cmdp, htab, 0);      
    } else if ( htab->last_entry->bIsOriginal == 1) {
      cf_log_syntax(player, cmd, "Error: '%s' is not an alias, cannot redefine.", alias);
      retval = -1;
    } else {
      cf_log_syntax(player, cmd, "Warning: Redefining alias '%s'", alias);
      retval = hashrepl2(alias, cmdp, htab, 0);
    }
  }
  return retval;
}			

CF_HAND(cf_alias)
{
    char *alias, *orig;
    int retval;

    alias = strtok(str, " \t=,");
    orig = strtok(NULL, " \t=,");

    retval = validate_aliases(player, 
			      (HASHTAB *) vp, orig, alias, 
			      "Entry", cmd);
    return retval;
}

/* ---------------------------------------------------------------------------
 * cf_flagalias: define a flag alias.
 */

CF_HAND(cf_flagalias)
{
    char *alias, *orig;
    int retval;

    alias = strtok(str, " \t=,");
    orig = strtok(NULL, " \t=,");
    
    retval = validate_aliases(player, 
			      &mudstate.flags_htab, orig, alias, 
			      "Flag", cmd);
    return retval;
}

CF_HAND(cf_flagname)
{
    char *alias, *orig;

    if (mudstate.initializing) {
	alias = strtok(str, " \t=,");
	orig = strtok(NULL, " \t=,");
	return (flagstuff_internal(orig,alias));
    }
    else
	return -1;
}

/* ---------------------------------------------------------------------------
 * cf_or_in_bits: OR in bits from namelist to a word.
 */

CF_HAND(cf_or_in_bits)
{
    char *sp;
    int f, success, failure;

    /* Walk through the tokens */

    success = failure = 0;
    sp = strtok(str, " \t");
    while (sp != NULL) {

	/* Set the appropriate bit */

	f = search_nametab(GOD, (NAMETAB *) extra, sp);
	if (f != -1) {
	    *vp |= f;
	    success++;
	} else {
	    cf_log_notfound(player, cmd, "Entry", sp);
	    failure++;
	}

	/* Get the next token */

	sp = strtok(NULL, " \t");
    }
    return cf_status_from_succfail(player, cmd, success, failure);
}

/* ---------------------------------------------------------------------------
 * cf_modify_bits: set or clear bits in a flag word from a namelist.
 */
CF_HAND(cf_modify_bits)
{
    char *sp;
    int f, negate, success, failure;

    /* Walk through the tokens */

    success = failure = 0;
    sp = strtok(str, " \t");
    while (sp != NULL) {

	/* Check for negation */

	negate = 0;
	if (*sp == '!') {
	    negate = 1;
	    sp++;
	}
	/* Set or clear the appropriate bit */

	f = search_nametab(GOD, (NAMETAB *) extra, sp);
	if (f != -1) {
	    if (negate)
		*vp &= ~f;
	    else
		*vp |= f;
	    success++;
	} else {
	    cf_log_notfound(player, cmd, "Entry", sp);
	    failure++;
	}

	/* Get the next token */

	sp = strtok(NULL, " \t");
    }
    return cf_status_from_succfail(player, cmd, success, failure);
}

/* ---------------------------------------------------------------------------
 * cf_set_bits: Clear flag word and then set specified bits from namelist.
 */

CF_HAND(cf_set_bits)
{
    char *sp;
    int f, success, failure;

    /* Walk through the tokens */

    success = failure = 0;
    *vp = 0;
    sp = strtok(str, " \t");
    while (sp != NULL) {

	/* Set the appropriate bit */

	f = search_nametab(GOD, (NAMETAB *) extra, sp);
	if (f != -1) {
	    *vp |= f;
	    success++;
	} else {
	    cf_log_notfound(player, cmd, "Entry", sp);
	    failure++;
	}

	/* Get the next token */

	sp = strtok(NULL, " \t");
    }
    return cf_status_from_succfail(player, cmd, success, failure);
}

/* ---------------------------------------------------------------------------
 * cf_set_flags: Clear flag word and then set from a flags htab.
 */

CF_HAND(cf_set_flags)
{
    char *sp;
    FLAGENT *fp;
    FLAGSET *fset;

    int success, failure, clear;

    /* Walk through the tokens */

    success = failure = 0;
    sp = strtok(str, " \t");
    fset = (FLAGSET *) vp;

    while (sp != NULL) {

	/* Set the appropriate bit */

	if (*sp == '!') {
	  clear = 1;
	  sp++;
	}
	else
	  clear = 0;

	fp = (FLAGENT *) hashfind(sp, &mudstate.flags_htab);
	if (fp != NULL) {
	    if (success == 0) {
		(*fset).word1 = 0;
		(*fset).word2 = 0;
		(*fset).word3 = 0;
		(*fset).word4 = 0;
	    }
	    if (clear) {
	      if (fp->flagflag & FLAG2)
		(*fset).word2 &= ~(fp->flagvalue);
	      else if (fp->flagflag & FLAG3)
		(*fset).word3 &= ~(fp->flagvalue);
	      else if (fp->flagflag & FLAG4)
		(*fset).word4 &= ~(fp->flagvalue);
	      else
		(*fset).word1 &= ~(fp->flagvalue);
	    }
	    else {
	      if (fp->flagflag & FLAG2)
		(*fset).word2 |= fp->flagvalue;
	      else if (fp->flagflag & FLAG3)
		(*fset).word3 |= fp->flagvalue;
	      else if (fp->flagflag & FLAG4)
		(*fset).word4 |= fp->flagvalue;
	      else
		(*fset).word1 |= fp->flagvalue;
	    }
	    success++;
	} else {
	    cf_log_notfound(player, cmd, "Entry", sp);
	    failure++;
	}

	/* Get the next token */

	sp = strtok(NULL, " \t");
    }
    if ((success == 0) && (failure == 0)) {
	(*fset).word1 = 0;
	(*fset).word2 = 0;
	(*fset).word3 = 0;
	(*fset).word4 = 0;

	return 0;
    }
    if (success > 0)
	return ((failure == 0) ? 0 : 1);
    return -1;
}

/* ---------------------------------------------------------------------------
 * cf_badname: Disallow use of player name/alias.
 */

CF_HAND(cf_badname)
{
    if (extra)
	badname_remove(str);
    else
	badname_add(str);
    return 0;
}

/* ---------------------------------------------------------------------------
 * cf_site: Update site information
 */

CF_HAND(cf_site)
{
    SITE *site, *last, *head;
    char *addr_txt, *mask_txt;
    struct in_addr addr_num, mask_num;
    unsigned long maskval;

    addr_txt = strtok(str, " \t=,");
    mask_txt = NULL;
    if (addr_txt)
	mask_txt = strtok(NULL, " \t=,");
    if (!addr_txt || !*addr_txt || !mask_txt || !*mask_txt) {
	cf_log_syntax(player, cmd, "Missing host address or mask.",
		      (char *) "");
	return -1;
    }
    addr_num.s_addr = inet_addr(addr_txt);
    if ( strchr(mask_txt, '/') != NULL ) {
       maskval = atol(mask_txt+1);
       if ((maskval < 0) || (maskval > 32)) {
	  cf_log_syntax(player, cmd, "Bad address mask: %s", mask_txt);
	  return -1;
       }
       maskval = (0xFFFFFFFFUL << (32 - maskval));
       mask_num.s_addr = htonl(maskval);
    } else
       mask_num.s_addr = inet_addr(mask_txt);

    if (addr_num.s_addr == -1) {
	cf_log_syntax(player, cmd, "Bad host address: %s", addr_txt);
	return -1;
    }
    head = (SITE *) * vp;
    /* Parse the access entry and allocate space for it */

    site = (SITE *) malloc(sizeof(SITE));

    /* Initialize the site entry */

    if ( extra & H_AUTOSITE ) {
       extra &= ~H_AUTOSITE;
       site->key = 1;
    } else {
       site->key = 0;
    }
    site->address.s_addr = addr_num.s_addr;
    site->mask.s_addr = mask_num.s_addr;
    site->flag = extra;
    site->next = NULL;

    /* Link in the entry.  Link it at the start if not initializing, at
     * the end if initializing.  This is so that entries in the config
     * file are processed as you would think they would be, while entries
     * made while running are processed first.
     */

    if (mudstate.initializing) {
	if (head == NULL) {
	    *vp = (int) site;
	} else {
	    for (last = head; last->next; last = last->next);
	    last->next = site;
	}
    } else {
	site->next = head;
	*vp = (int) site;
    }
    if ( site->key == 1 )
       return 777;
    else
       return 0;
}

/* ---------------------------------------------------------------------------
 * cf_cf_access: Set access on config directives
 */

CF_HAND(cf_cf_access)
{
    CONF *tp;
    char *ap;

    for (ap = str; *ap && !isspace((int)*ap); ap++);
    if (*ap)
	*ap++ = '\0';

    for (tp = conftable; tp->pname; tp++) {
	if (!strcmp(tp->pname, str)) {
	    return (cf_modify_bits(&tp->flags, ap, extra,
				   player, cmd));
	}
    }
    cf_log_notfound(player, cmd, "Config directive", str);
    return -1;
}

/* ---------------------------------------------------------------------------
 * cf_include: Read another config file.  Only valid during startup.
 */

CF_HAND(cf_include)
{
    FILE *fp;
    char *cp, *ap, *zp, *buf;

    extern int FDECL(cf_set, (char *, char *, dbref));


    if (!mudstate.initializing)
	return -1;

    STARTLOG(LOG_ALWAYS, "CNF", "INCL")
      log_text((char *) "Conf including: ");
      log_text(str);
    ENDLOG

    fp = fopen(str, "r");
    if (fp == NULL) {
	cf_log_notfound(player, cmd, "Config file", str);
	return -1;
    }
    buf = alloc_lbuf("cf_include");
    fgets(buf, LBUF_SIZE, fp);
    while (!feof(fp)) {
	cp = buf;
	if (*cp == '#') {
	    fgets(buf, LBUF_SIZE, fp);
	    continue;
	}
	/* Not a comment line.  Strip off the NL and any characters
	 * following it.  Then, split the line into the command and
	 * argument portions (separated by a space).  Also, trim off
	 * the trailing comment, if any (delimited by #)
	 */

	for (cp = buf; *cp && *cp != '\n'; cp++);
	*cp = '\0';		/* strip \n */
	for (cp = buf; *cp && isspace((int)*cp); cp++);	/* strip spaces */
	for (ap = cp; *ap && !isspace((int)*ap); ap++);	/* skip over command */
	if (*ap)
	    *ap++ = '\0';	/* trim command */
	for (; *ap && isspace((int)*ap); ap++);	/* skip spaces */
	for (zp = ap; *zp && (*zp != '#'); zp++);	/* find comment */
	if (*zp)
	    *zp = '\0';		/* zap comment */
	for (zp = zp - 1; zp >= ap && isspace((int)*zp); zp--)
	    *zp = '\0';		/* zap trailing spcs */

	cf_set(cp, ap, player);
	fgets(buf, LBUF_SIZE, fp);
    }
    free_lbuf(buf);
    fclose(fp);
    return 0;
}

extern CF_HDCL(cf_access);
extern CF_HDCL(cf_cmd_alias);
extern CF_HDCL(cf_acmd_access);
extern CF_HDCL(cf_attr_access);
extern CF_HDCL(cf_ntab_access);
extern CF_HDCL(cf_func_access);
extern CF_HDCL(cf_cmd_ignore);

/* ---------------------------------------------------------------------------
 * conftable: Table for parsing the configuration file.
 */

CONF conftable[] =
{
    {(char *) "abort_on_bug",
     cf_bool, CA_DISABLED, &mudconf.abort_on_bug, 0, CA_WIZARD,
     (char *)"Bring down game on error?"},
    {(char *) "access",
     cf_access, CA_GOD | CA_IMMORTAL, NULL,
     (pmath2) access_nametab, CA_WIZARD,
     (char *) "Configure command access permissions."},
    {(char *) "ahear_maxcount",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.ahear_maxcount, 0, CA_PUBLIC,
     (char *) "Maximum listen/ahear iterations?\r\n"\
              "                             Default: 30   Value: %d"},
    {(char *) "ahear_maxtime",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.ahear_maxtime, 0, CA_PUBLIC,
     (char *) "Maximum listen/ahear time laps (in seconds)?\r\n"\
              "                             Default: 60   Value: %d"},
    {(char *) "alias",
     cf_cmd_alias, CA_GOD | CA_IMMORTAL, (int *) &mudstate.command_htab, 0, CA_WIZARD,
     (char *) "Define command alises."},
    {(char *) "alt_inventories",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.alt_inventories, 0, CA_PUBLIC,
     (char *) "Enable alternate inventories (worn/wield)."},
    {(char *) "altover_inv",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.altover_inv, 0, CA_PUBLIC,
     (char *) "Seperate displays of inventories (worn/wield)."},
    {(char *) "always_blind",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.always_blind, 0, CA_PUBLIC,
     (char *) "BLIND flag reversed (always blind?)"},
    {(char *) "areg_lim",
     cf_int, CA_GOD | CA_IMMORTAL, (int *) &mudconf.areg_lim, 0, CA_WIZARD,
     (char *) "Specify limit on registers from single email.\r\n"\
              "                             Default: 3   Value: %d"},
    {(char *) "attr_access",
     cf_attr_access, CA_GOD | CA_IMMORTAL, NULL,
     (pmath2) attraccess_nametab, CA_WIZARD,
     (char *) "Configure attribute permissions (internal)."},
    {(char *) "attr_alias",
     cf_alias, CA_GOD | CA_IMMORTAL, (int *) &mudstate.attr_name_htab, 0, CA_WIZARD,
     (char *) "Define attribute aliases."},
    {(char *) "attr_cmd_access",
     cf_acmd_access, CA_GOD | CA_IMMORTAL, NULL,
     (pmath2) access_nametab, CA_WIZARD,
     (char *) "Configure attribute access permissions."},
    {(char *) "allow_ansinames",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.allow_ansinames, 0, CA_PUBLIC,
     (char *) "Allow names to be ansified?\r\n"\
              "                             Default: 15   Value: %d"},
    {(char *) "allow_whodark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.allow_whodark, 0, CA_PUBLIC,
     (char *) "Allow dark players to hide from WHO/DOING?"},
    {(char *) "areg_file",
     cf_string, CA_DISABLED, (int *) mudconf.areg_file, 32, CA_WIZARD,
     (char *) "Specify the auto-register txt file."},
    {(char *) "aregh_file",
     cf_string, CA_DISABLED, (int *) mudconf.aregh_file, 32, CA_WIZARD,
     (char *) "Specify the auto-register with connects file." },
    {(char *) "bad_name",
     cf_badname, CA_GOD | CA_IMMORTAL, NULL, 0, CA_WIZARD,
     (char *) "Specify a list of bad player names."},
    {(char *) "badsite_file",
     cf_string, CA_DISABLED, (int *) mudconf.site_file, 32, CA_WIZARD,
     (char *) "Specify the forbid site file."},
    {(char *) "bcc_hidden",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.bcc_hidden, 0, CA_WIZARD,
     (char *) "Does +bcc in mail hide who mail from in target?"},
    {(char *) "brace_compatibility",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.brace_compatibility, 0, CA_WIZARD,
     (char *) "Are braces MUX/TM3 compatible?"},
     {(char *) "exits_connect_rooms",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.exits_conn_rooms, 0, CA_WIZARD,
     (char *) "Is a room with an exit considered floating?"},
    {(char *) "cache_depth",
     cf_int, CA_DISABLED, &mudconf.cache_depth, 0, CA_WIZARD,
     (char *) "Show what the current cache debth is.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "cache_names",
     cf_bool, CA_DISABLED, &mudconf.cache_names, 0, CA_WIZARD,
     (char *) "Are names being cached?"},
    {(char *) "cache_steal_dirty",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.cache_steal_dirty, 0, CA_WIZARD,
     (char *) "Does the cache do dirty reads?"},
    {(char *) "cache_trim",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.cache_trim, 0, CA_WIZARD,
     (char *) "Is the cache trimmed back to initial value?"},
    {(char *) "cache_width",
     cf_int, CA_DISABLED, &mudconf.cache_width, 0, CA_WIZARD,
     (char *) "What is the current cache width?\r\n"
              "                             Default: 541   Value: %d"},
    {(char *) "check_interval",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.check_interval, 0, CA_WIZARD,
     (char *) "What is the DBCK interval?\r\n"\
              "                             Default: 600   Value: %d"},
    {(char *) "check_offset",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.check_offset, 0, CA_WIZARD,
     (char *) "What is the offset of internal checks?\r\n"\
              "                             Default: 300   Value: %d"},
    {(char *) "clone_copies_cost",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.clone_copy_cost, 0, CA_PUBLIC,
     (char *) "Is the cost copied with a @clone?"},
    {(char *) "comcost",
     cf_int, CA_WIZARD, &mudconf.comcost, 0, CA_PUBLIC,
     (char *) "This is the cost per comsystem usage\r\n"\
              "                             Default: 5   Value: %d"},
    {(char *) "command_dark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.comm_dark, 0, CA_PUBLIC,
     (char *) "Are objects with $commands DARK?"},
    {(char *) "command_quota_increment",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.cmd_quota_incr, 0, CA_WIZARD,
     (char *) "Number of commands per timeslice per user.\r\n"\
              "      -- This is not used    Default: 0   Value: %d"},
    {(char *) "command_quota_max",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.cmd_quota_max, 0, CA_WIZARD,
     (char *) "Max commands allowed per timeslice per user.\r\n"\
              "      -- This is not used    Default: 100   Value: %d"},
    {(char *) "compress_program",
     cf_string, CA_DISABLED, (int *) mudconf.compress, 128, CA_WIZARD,
     (char *) "Compression program for db compression.\r\n"\
              "                                  (compress) is default"},
    {(char *) "compression",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.compress_db, 0, CA_WIZARD,
     (char *) "Is the db compressed on writing/reading?"},
    {(char *) "config_access",
     cf_cf_access, CA_GOD | CA_IMMORTAL, NULL,
     (pmath2) access_nametab, CA_WIZARD,
     (char *) "Define config paramater access permissions."},
    {(char *) "conn_timeout",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.conn_timeout, 0, CA_WIZARD,
     (char *) "Define what the timeout is on connect screen.\r\n"\
              "                             Default: 120   Value: %d"},
    {(char *) "connect_file",
     cf_string, CA_DISABLED, (int *) mudconf.conn_file, 32, CA_WIZARD,
     (char *) "Define the connect file."},
    {(char *) "connect_reg_file",
     cf_string, CA_DISABLED, (int *) mudconf.creg_file, 32, CA_WIZARD,
     (char *) "Define the registration file."},
    {(char *) "manlog_file",
     cf_string, CA_DISABLED, (int *) mudconf.manlog_file, 32, CA_WIZARD,
     (char *) "Define file used with @log command."},
    {(char *) "cpuintervalchk",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.cpuintervalchk, 0, CA_WIZARD,
     (char *) "Define percentage before cpu-enforcement.\r\n"\
              "                             Default: 80   Value: %d"},
    {(char *) "cputimechk",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.cputimechk, 0, CA_WIZARD,
     (char *) "Define time in seconds before cpu-enforcement.\r\n"\
              "                             Default: 60   Value: %d"},
    {(char *) "lastsite_paranoia",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.lastsite_paranoia, 0, CA_WIZARD,
     (char *) "Define DoS site paranoia level (0, 1, 2).\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "lattr_default_oldstyle",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.lattr_default_oldstyle, 0, CA_PUBLIC,
     (char *) "Snuff the '#-1' from lattr()."},
    {(char *) "lcon_checks_dark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.lcon_checks_dark, 0, CA_PUBLIC,
     (char *) "Lcon/Xcon checks dark/unfindable?"},
    {(char *) "max_cpu_cycles",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_cpu_cycles, 0, CA_WIZARD,
     (char *) "Max cpu slams allowed before smackdown.\r\n"\
              "                             Default: 3   Value: %d"},
    {(char *) "max_dest_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_dest_limit, 0, CA_WIZARD,
     (char *) "Max times user allowed to use @destroy.\r\n"\
              "                             Default: 1000   Value: %d"},
    {(char *) "max_lastsite_cnt",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_lastsite_cnt, 0, CA_WIZARD,
     (char *) "Max times samesite allowed to connect in row.\r\n"\
              "                             Default: 20   Value: %d"},
    {(char *) "max_pcreate_lim",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_pcreate_lim, 0, CA_WIZARD,
     (char *) "Max times a player can create on connect screen.\r\n"\
              "         (-1 is unlimited)   Default: -1   Value: %d"},
    {(char *) "max_pcreate_time",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_pcreate_time, 0, CA_WIZARD,
     (char *) "Max timeframe max player creates can occur.\r\n"\
              "        (Value in seconds)   Default: 60   Value: %d"},
    {(char *) "max_percentsubs",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_percentsubs, 0, CA_WIZARD,
     (char *) "Max allowable percent substitutions per command.\r\n"\
              "                             Default: 1000000   Value: %d"},
    {(char *) "max_vattr_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_vattr_limit, 0, CA_WIZARD,
     (char *) "Max times user can create new user attribs.\r\n"\
              "                             Default: 10000   Value: %d"},
    {(char *) "min_con_attempt",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.min_con_attempt, 0, CA_WIZARD,
     (char *) "Time (in seconds) to allow multiple connects.\r\n"\
              "                             Default: 60   Value: %d"},
    {(char *) "cpu_secure_lvl",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.cpu_secure_lvl, 0, CA_WIZARD,
     (char *) "Level of smackdown you want with CPU abusers.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "crash_database",
     cf_string, CA_DISABLED, (int *) mudconf.crashdb, 128, CA_WIZARD,
     (char *) "Database name for attempted write on crash."},
    {(char *) "create_max_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.createmax, 0, CA_PUBLIC,
     (char *) "Max cost of item.\r\n"\
              "                             Default: 505   Value: %d"},
    {(char *) "create_min_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.createmin, 0, CA_PUBLIC,
     (char *) "Min cost of item.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "dark_sleepers",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.dark_sleepers, 0, CA_PUBLIC,
     (char *) "Are disconnected players DARK by default?"},
    {(char *) "debug_id",
     cf_int, CA_DISABLED, &mudconf.debug_id, 0, CA_WIZARD,
     (char *) "Unique key for debug monitor.\r\n"\
              "                             Default: 42010   Value: %d"},
    {(char *) "authenticate",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.authenticate, 0, CA_WIZARD,
     (char *) "Are site AUTH/IDENT lookups done?"},
    {(char *) "default_home",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.default_home, 0, CA_WIZARD,
     (char *) "Player's default home.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "descs_are_local",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.descs_are_local, 0, CA_PUBLIC,
     (char *) "Are @descs and other did_it calls local?"},
    {(char *) "dig_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.digcost, 0, CA_PUBLIC,
     (char *) "Cost of @dig command.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "door_file",
     cf_string, CA_DISABLED, (int *) mudconf.door_file, 32, CA_WIZARD,
     (char *) "File used for @door command."},
    {(char *) "door_index",
     cf_string, CA_DISABLED, (int *) mudconf.door_indx, 32, CA_WIZARD,
     (char *) "Index used for @door command."},
    {(char *) "down_file",
     cf_string, CA_DISABLED, (int *) mudconf.down_file, 32, CA_WIZARD,
     (char *) "File used @disable logins in effect."},
    {(char *) "down_motd_message",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.downmotd_msg, 1024, CA_WIZARD,
     (char *) "Message seen when @disable logins in effect."},
    {(char *) "dump_interval",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.dump_interval, 0, CA_WIZARD,
     (char *) "What is the database dump interval?\r\n"\
              "                             Default: 3600   Value: %d"},
    {(char *) "dump_message",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.dump_msg, 128, CA_WIZARD,
     (char *) "Message seen BEFORE database dumps."},
    {(char *) "postdump_message",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.postdump_msg, 128, CA_WIZARD,
     (char *) "Message seen AFTER database dumps."},
    {(char *) "dump_offset",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.dump_offset, 0, CA_WIZARD,
     (char *) "What is the base offset between dumps?\r\n"\
              " -- If 0 use 'dump_interval' Default: 0   Value: %d"},
    {(char *) "earn_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.paylimit, 0, CA_PUBLIC,
     (char *) "What is the ceiling on money someone can get?\r\n"\
              "                             Default: 10000   Value: %d"},
    {(char *) "empower_fulltel",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.empower_fulltel, 0, CA_PUBLIC,
     (char *) "Does FULLTEL handle more than self?"},
    {(char *) "enable_tstamps",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.enable_tstamps, 0, CA_PUBLIC,
     (char *) "Are timestamps/modifystamps enabled?"},
    {(char *) "enforce_unfindable",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.enforce_unfindable, 0, CA_PUBLIC,
     (char *) "Is UNFINDABLE/DARK enforced for locations?"},
    {(char *) "error_file",
     cf_string, CA_DISABLED, (int *) mudconf.error_file, 32, CA_WIZARD,
     (char *) "File used for huh? messages."},
    {(char *) "error_index",
     cf_string, CA_DISABLED, (int *) mudconf.error_indx, 32, CA_WIZARD,
     (char *) "Index used for huh? messages."},
    {(char *) "examine_flags",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.ex_flags, 0, CA_PUBLIC,
     (char *) "Are flags shown on examine?"},
    {(char *) "examine_public_attrs",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.exam_public, 0, CA_PUBLIC,
     (char *) "Are public attributes seen with examine?"},
    {(char *) "examine_restrictive",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.examine_restrictive, 0, CA_PUBLIC,
     (char *) "What level is restrictions on Examine?\r\n"\
              "  (0-off 1-6 level based)    Default: 0   Value: %d"},
    {(char *) "exit_flags",
     cf_set_flags, CA_GOD | CA_IMMORTAL, (int *) &mudconf.exit_flags, 0, CA_PUBLIC,
     (char *) "These are default flags set on new exits."},
    {(char *) "exit_quota",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.exit_quota, 0, CA_PUBLIC,
     (char *) "How much quota does an exit take up?\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *) "expand_goto",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.expand_goto, 0, CA_PUBLIC,
     (char *) "Does exit movement expand to 'goto'?"},
    {(char *) "fascist_teleport",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.fascist_tport, 0, CA_PUBLIC,
     (char *) "Is @teleport limited to jump_ok only?"},
    {(char *) "find_money_chance",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.payfind, 0, CA_PUBLIC,
     (char *) "Chance to find money when you move. (1/X)\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "flag_alias",
     cf_flagalias, CA_GOD | CA_IMMORTAL, NULL, 0, CA_WIZARD,
     (char *) "Define flag aliases."},
    {(char *) "flag_name",
     cf_flagname, CA_GOD | CA_IMMORTAL, NULL, 0, CA_WIZARD,
     (char *) "Rename flags (in .conf file ONLY!)."},
    {(char *) "forbid_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.access_list,
     H_FORBIDDEN, CA_WIZARD,
     (char *) "This specifies sites for forbid."},
    {(char *) "forbid_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.forbid_host, 1000, CA_WIZARD,
     (char *) "This specifies sites by NAME to forbid."},
    {(char *) "fork_dump",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.fork_dump, 0, CA_PUBLIC,
     (char *) "Are dumps done in the background?"},
    {(char *) "fork_vfork",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.fork_vfork, 0, CA_WIZARD,
     (char *) "Is vfork used instead of fork?"},
    {(char *) "format_compatibility",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.format_compatibility, 0, CA_PUBLIC,
     (char *) "Are @<attribute> formats MUSH/MUX compatible?"},
    {(char *) "format_contents",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.fmt_contents, 0, CA_PUBLIC,
     (char *) "Can you use @conformat for content formatting?"},
    {(char *) "format_exits",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.fmt_exits, 0, CA_PUBLIC,
     (char *) "Can you use @exitformat for exit formatting?"},
    {(char *) "format_name",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.fmt_names, 0, CA_PUBLIC,
     (char *) "Can you use @nameformat for @name formatting?"},
    {(char *) "formats_are_local",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.formats_are_local, 0, CA_PUBLIC,
     (char *) "Are @nameformat/@conformat/@exitformat local?"},
    {(char *) "full_file",
     cf_string, CA_DISABLED, (int *) mudconf.full_file, 32, CA_WIZARD,
     (char *) "File used when site is full."},
    {(char *) "full_motd_message",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.fullmotd_msg, 1024, CA_WIZARD,
     (char *) "This is the current online @motd message."},
    {(char *) "function_access",
     cf_func_access, CA_GOD | CA_IMMORTAL, NULL, 
     (pmath2) access_nametab, CA_WIZARD,
     (char *) "Configure permissions for functions."},
    {(char *) "function_alias",
     cf_alias, CA_GOD | CA_IMMORTAL, (int *) &mudstate.func_htab, 0, CA_WIZARD,
     (char *) "Define aliases for functions."},
    {(char *) "function_invocation_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.func_invk_lim, 0, CA_WIZARD,
     (char *) "The current function invocation limit.\r\n"\
              "                             Default: 2500   Value: %d"},
    {(char *) "function_recursion_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.func_nest_lim, 0, CA_WIZARD,
     (char *) "The current function recursion limit.\r\n"\
              "(Max is 300)                 Default: 50   Value: %d"},
    {(char *) "wildmatch_limit",
     cf_int, CA_GOD | CA_IMMORTAL, (int *) &mudconf.wildmatch_lim, 0, CA_WIZARD,
     (char *) "Ceiling on wildmatch recursion (DoS).\r\n"\
              "        -- 0 is all wizards  Default: 100000   Value: %d"},
    {(char *) "gconf_file",
     cf_string, CA_DISABLED, (int *) mudconf.gconf_file, 32, CA_WIZARD,
     (char *) "File for guest from bad sites."},
    {(char *) "gdbm_database",
     cf_string, CA_DISABLED, (int *) mudconf.gdbm, 128, CA_WIZARD,
     (char *) "Name of the gdbm database."},
    {(char *) "global_aconnect",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.global_aconn, 0, CA_PUBLIC,
     (char *) "Are aconnects enabled in master room?"},
    {(char *) "global_adisconnect",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.global_adconn, 0, CA_PUBLIC,
     (char *) "Are adisconnects enabled in master room?"},
    {(char *) "global_ansimask",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_ansimask, 0, CA_PUBLIC,
     (char *) "Mask of ansi allowed to use in ansi()/%%c.\r\n"\
              "                             Default: 2097151   Value: %d"},
    {(char *) "global_attrdefault",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_attrdefault, 0, CA_PUBLIC,
     (char *) "Object that attribute locks are checked on set.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_clone_exit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_clone_exit, 0, CA_PUBLIC,
     (char *) "Object that EXIT attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_clone_obj",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_clone_obj, 0, CA_PUBLIC,
     (char *) "Object that GENERIC attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_clone_player",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_clone_player, 0, CA_PUBLIC,
     (char *) "Object that PLAYER attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_clone_room",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_clone_room, 0, CA_PUBLIC,
     (char *) "Object that ROOM attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_clone_thing",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_clone_thing, 0, CA_PUBLIC,
     (char *) "Object that THING attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_error_obj",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_error_obj, 0, CA_PUBLIC,
     (char *) "Object who's @va is executed for non-cmds.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_parent_exit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_parent_exit, 0, CA_PUBLIC,
     (char *) "Object that EXIT attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_parent_obj",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_parent_obj, 0, CA_PUBLIC,
     (char *) "Object that GENERIC attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_parent_player",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_parent_player, 0, CA_PUBLIC,
     (char *) "Object that PLAYER attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_parent_room",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_parent_room, 0, CA_PUBLIC,
     (char *) "Object that ROOM attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "global_parent_thing",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.global_parent_thing, 0, CA_PUBLIC,
     (char *) "Object that THING attributes are inherited from.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "good_name",
     cf_badname, CA_GOD | CA_IMMORTAL, NULL, 1, CA_WIZARD,
     (char *) "Remove names from the bad_name list."},
    {(char *) "goodmail_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.goodmail_host, 1000, CA_WIZARD,
     (char *) "Mail addresses to ALLOW ALWAYS from autoreg."},
    {(char *) "guest_file",
     cf_string, CA_DISABLED, (int *) mudconf.guest_file, 32, CA_WIZARD,
     (char *) "File used for guest connections."},
    {(char *) "guild_default",
     cf_string, CA_GOD | CA_IMMORTAL | CA_WIZARD, (int *)mudconf.guild_default, 11, CA_WIZARD,
     (char *) "Default guild set on new players."},
    {(char *) "guild_hdr",
     cf_string, CA_GOD | CA_IMMORTAL | CA_WIZARD, (int *)mudstate.guild_hdr, 11, CA_WIZARD,
     (char *) "Default Guild column name in WHO/DOING."},
    {(char *) "guild_attrname", 
     cf_string, CA_GOD | CA_IMMORTAL | CA_WIZARD, (int *) mudconf.guild_attrname, 32, CA_WIZARD,
     (char *) "Which attribute to extract the guild info from. (Default: GUILD)"},
    {(char *) "guest_namelist", 
     cf_dynguest, CA_GOD | CA_IMMORTAL, (int *) mudconf.guest_namelist, 1000, CA_WIZARD,
     (char *) "List of guests that are dyanmically named."},
    {(char *) "hackattr_nowiz",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.hackattr_nowiz, 0, CA_WIZARD,
     (char *) "Are _attribs NOT wizard owned?"},
    {(char *) "hackattr_see",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.hackattr_see, 0, CA_WIZARD,
     (char *) "Are _attribs NOT wizard viewable?"},
    {(char *) "hasattrp_compat",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.hasattrp_compat, 0, CA_PUBLIC,
     "Should hasattrp() check only parents? (YES=FALSE, NO=TRUE)"},
    {(char *) "heavy_cpu_max",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.heavy_cpu_max, 0, CA_WIZARD,
     (char *) "Repitions allowed of heavy cpu functions.\r\n"\
              "                             Default: 50   Value: %d"},
    {(char *) "help_file",
     cf_string, CA_DISABLED, (int *) mudconf.help_file, 32, CA_WIZARD,
     (char *) "File used for help."},
    {(char *) "help_index",
     cf_string, CA_DISABLED, (int *) mudconf.help_indx, 32, CA_WIZARD,
     (char *) "Index used for help."},
    {(char *) "hide_nospoof",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.hide_nospoof, 0, CA_WIZARD,
     (char *) "Is the NOSPOOF flag hidden from others?"},
    {(char *) "hook_cmd",
     cf_hook, CA_GOD | CA_IMMORTAL, &mudconf.hook_cmd, 0, CA_WIZARD,
     (char *) "Set/remove HOOK bitmasks from commands."},
    {(char *) "hook_obj",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.hook_obj, 0, CA_WIZARD,
     (char *) "Global Hook Object dbref#.\r\n"\
              "    (-1 for no defined obj)  Default: -1   Value: %d"},
    {(char *) "hostnames",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.use_hostname, 0, CA_WIZARD,
     (char *) "Are hostnames viewable or just numerics?"},
    {(char *) "html_port",
     cf_int, CA_DISABLED, &mudconf.html_port, 0, CA_WIZARD,
     (char *) "Specifies what the HTML port is.\r\n"\
              "                             Default: 6251   Value: %d"},
    {(char *) "idle_message",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.idle_message, 0, CA_WIZARD,
     (char *) "Do wizards receive message when idled out?"},
    {(char *) "idle_wiz_cloak",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.idle_wiz_cloak, 0, CA_WIZARD,
     (char *) "Do wizards cloak when idled out?"},
    {(char *) "idle_wiz_dark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.idle_wiz_dark, 0, CA_WIZARD,
     (char *) "Do wizards go dark when idled out?"},
    {(char *) "idle_interval",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.idle_interval, 0, CA_WIZARD,
     (char *) "Interval between idle checks.\r\n"\
              "                             Default: 60   Value: %d"},
    {(char *) "idle_timeout",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.idle_timeout, 0, CA_WIZARD,
     (char *) "Value in seconds before someone idles out.\r\n"\
              "                             Default: 3600   Value: %d"},
    {(char *) "imm_nomod",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.imm_nomod, 0, CA_WIZARD,
     (char *) "Can only immortal set/effect NOMODIFY flag?"},
    {(char *) "include",
     cf_include, CA_DISABLED, NULL, 0, CA_WIZARD,
     (char *) "Process config params by filename on startup."},
    {(char *) "initial_size",
     cf_int, CA_DISABLED, &mudconf.init_size, 0, CA_WIZARD,
     (char *) "Initial database size.\r\n"\
              "                             Default: 20000   Value: %d"},
    {(char *) "data_dir", 
     cf_string, CA_DISABLED, (int *) mudconf.data_dir, 128, CA_WIZARD,
     (char *) "Location of data files."},
    {(char *) "txt_dir",
     cf_string, CA_DISABLED, (int *) mudconf.txt_dir, 128, CA_WIZARD,
     (char *) "Location of txt files."},
    {(char *) "input_database",
     cf_string, CA_DISABLED, (int *) mudconf.indb, 128, CA_WIZARD,
     (char *) "Name of the input database."},
    {(char *) "internal_compress_string",
     cf_bool, CA_DISABLED, &mudconf.intern_comp, 0, CA_WIZARD,
     (char *) "Are strings compressed internally?"},
    {(char *) "inventory_name",
     cf_string, CA_IMMORTAL, (int *) mudconf.invname, 79, CA_PUBLIC,
     (char *) "What is the inventory name for alt inventory?"},
    {(char *) "kill_guarantee_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.killguarantee, 0, CA_PUBLIC,
     (char *) "How much money to guarentee a kill?\r\n"\
              "                             Default: 100   Value: %d"},
    {(char *) "kill_max_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.killmax, 0, CA_PUBLIC,
     (char *) "Maximum money used for kill.\r\n"\
              "                             Default: 100   Value: %d"},
    {(char *) "kill_min_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.killmin, 0, CA_PUBLIC,
     (char *) "Minimum money used for kill.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "link_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.linkcost, 0, CA_PUBLIC,
     (char *) "Cost to @link.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *) "list_access",
     cf_ntab_access, CA_GOD | CA_IMMORTAL, (int *) list_names, 
     (pmath2) access_nametab, CA_WIZARD,
     (char *) "Change permissions of options with @list."},
    {(char *) "lock_recursion_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.lock_nest_lim, 0, CA_WIZARD,
     (char *) "Current recursion limit on @locks.\r\n"\
              "                             Default: 20   Value: %d"},
    {(char *) "log",
     cf_modify_bits, CA_GOD | CA_IMMORTAL, &mudconf.log_options,
     (pmath2) logoptions_nametab, CA_WIZARD,
     (char *) "Current log options enabled."},
    {(char *) "log_command_list", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.log_command_list, 1000, CA_WIZARD,
     (char *) "List of commands that are being logged."},
    {(char *) "log_options",
     cf_modify_bits, CA_GOD | CA_IMMORTAL, &mudconf.log_info,
     (pmath2) logdata_nametab, CA_WIZARD,
     (char *) "Options to be included with logging."},
    {(char *) "login_to_prog",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.login_to_prog, 0, CA_PUBLIC,
     (char *) "Can a user log into running @program?"},
    {(char *) "logout_cmd_access",
     cf_ntab_access, CA_GOD | CA_IMMORTAL, (int *) logout_cmdtable,
     (pmath2) access_nametab, CA_WIZARD,
     (char *) "Configure access of commands on connect."},
    {(char *) "logout_cmd_alias",
     cf_alias, CA_GOD | CA_IMMORTAL, (int *) &mudstate.logout_cmd_htab, 0, CA_WIZARD,
     (char *) "Define aliases for commands on connect."},
    {(char *) "look_moreflags",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.look_moreflags, 0, CA_PUBLIC,
     (char *) "Do global flags show up by attributes?"},
    {(char *) "look_obey_terse",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.terse_look, 0, CA_PUBLIC,
     (char *) "Does 'look' obey the TERSE flag?"},
    {(char *) "lnum_compat",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.lnum_compat, 0, CA_PUBLIC,
     (char *) "Is lnum()/lnum2() TinyMUSH/MUX compatible?"},
    {(char *) "nand_compat",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.nand_compat, 0, CA_PUBLIC,
     (char *) "Use the pre-pl15 nand() behaviour?. (DEPRECATED)"},
    {(char *) "machine_command_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.machinecost, 0, CA_PUBLIC,
     (char *) "Cost of running things from a non-player (1/X)\r\n"\
              "                             Default: 64   Value: %d"},
    {(char *) "mail_anonymous",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.mail_anonymous, 30, CA_WIZARD,
     (char *) "Anonymous player name that /anon mail sent has."},
    {(char *) "mail_autodeltime",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.mail_autodeltime, 0, CA_WIZARD,
     (char *) "Default mail autodelete time for messages.\r\n"\
              "          (-1 is inactive)   Default: 21   Value: %d"},
    {(char *) "mail_def_object",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.mail_def_object, 0, CA_WIZARD,
     (char *) "Mail object used for global eval aliases\r\n"\
              "          (-1 is inactive)   Default: -1   Value: %d"},
    {(char *) "mail_default",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.mail_default, 0, CA_PUBLIC,
     (char *) "Does 'mail' mimic 'mail/status'?"},
    {(char *) "mail_hidden",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.mail_hidden, 0, CA_PUBLIC,
     (char *) "Does mail/anon hide who is sent to?"},
    {(char *) "mail_tolist",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.mail_tolist, 0, CA_PUBLIC,
     (char *) "Does 'mail' display a 'To:' list?"},
    {(char *) "mail_verbosity",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.mail_verbosity, 0, CA_WIZARD,
     (char *) "Mail notices show subj. and sent to discon'd players.\r\n"\
              "          (-1 is inactive)   Default: 0    Value: %d"},
    {(char *) "maildelete",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.maildelete, 0, CA_PUBLIC,
     (char *) "Is mail set up for auto-purging?"},
    {(char *) "mailbox_size",
     cf_mailint, CA_GOD | CA_IMMORTAL | CA_WIZARD, &mudconf.mailbox_size, 0, CA_WIZARD,
     (char *) "Current default mailbox size.\r\n"\
              "                             Default: 99   Value: %d"},
    {(char *) "mailinclude_file",
     cf_string, CA_DISABLED, (int *) mudconf.mailinclude_file, 32, CA_WIZARD,
     (char *) "File included when player registers."},
    {(char *) "mailmax_send",
     cf_int, CA_GOD | CA_IMMORTAL | CA_WIZARD, &mudconf.mailmax_send, 0, CA_WIZARD,
     (char *) "Maximum number of players in a single message.\r\n"\
              "                             Default: 100   Value: %d"},
    {(char *) "mailprog",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.mailprog, 16, CA_WIZARD,
     (char *) "Program used for autoregistering (Def. elm)."},
    {(char *) "mailsub",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.mailsub, 0, CA_WIZARD,
     (char *) "Are subjects included in autoregistration?"},
    {(char *) "master_room",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.master_room, 0, CA_WIZARD,
     (char *) "Dbref# of the master room.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "match_own_commands",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.match_mine, 0, CA_PUBLIC,
     (char *) "Are commands matched on enactor?"},
    {(char *) "max_folders",
     cf_int, CA_GOD | CA_IMMORTAL | CA_WIZARD, &mudconf.mailmax_fold, 0, CA_PUBLIC,
     (char *) "Maximum mail folders allowed.\r\n"\
              "                             Default: 20   Value: %d"},
    {(char *) "max_players",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_players, 0, CA_WIZARD,
     (char *) "Maximum players allowed.\r\n"\
              "   -- '-1' specifies ceiling Default: -1   Value: %d"},
    {(char *) "max_sitecons",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_sitecons, 0, CA_WIZARD,
     (char *) "Maximum connects allowed per unique site.\r\n"\
              "                             Default: 20   Value: %d"},
    {(char *) "maximum_size",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_size, 0, CA_WIZARD,
     (char *) "DB Ceiling for max objects.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "money_lim_off",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.money_limit[0], 0, CA_WIZARD,
     (char *) "Define money for @depower NOSTEAL/NOGIVE.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "money_lim_gm",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.money_limit[1], 0, CA_WIZARD,
     (char *) "Define money for GM level @depower.\r\n"\
              "                             Default: 500   Value: %d"},
    {(char *) "money_lim_arch",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.money_limit[2], 0, CA_WIZARD,
     (char *) "Define money for ARCH level @depower.\r\n"\
              "                             Default: 2000   Value: %d"},
    {(char *) "money_lim_counc",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.money_limit[3], 0, CA_WIZARD,
     (char *) "Define money for Councelor level @depower.\r\n"\
              "                             Default: 5000   Value: %d"},
    {(char *) "money_name_plural",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.many_coins, 32, CA_PUBLIC,
     (char *) "Define plural name for money."},
    {(char *) "money_name_singular",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.one_coin, 32, CA_PUBLIC,
     (char *) "Define singular name for money."},
    {(char *) "motd_file",
     cf_string, CA_DISABLED, (int *) mudconf.motd_file, 32, CA_WIZARD,
     (char *) "File used for motd."},
    {(char *) "motd_message",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.motd_msg, 1024, CA_WIZARD,
     (char *) "Text used for @motd online."},
    {(char *) "muddb_name",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.muddb_name, 32, CA_PUBLIC,
     (char *) "The name used for the RhostMUSH DB's (mail/news)."},
    {(char *) "mud_name",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.mud_name, 32, CA_PUBLIC,
     (char *) "The name used for the RhostMUSH."},
    {(char *) "must_unlquota",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.must_unlquota, 0, CA_WIZARD,
     (char *) "Unlock @quota before giving more?"},
    {(char *) "news_file",
     cf_string, CA_DISABLED, (int *) mudconf.news_file, 32, CA_WIZARD,
     (char *) "File used for news."},
    {(char *) "news_index",
     cf_string, CA_DISABLED, (int *) mudconf.news_indx, 32, CA_WIZARD,
     (char *) "Index used for news."},
    {(char *) "newuser_file",
     cf_string, CA_DISABLED, (int *) mudconf.crea_file, 32, CA_WIZARD,
     (char *) "File used for new player created."},
    {(char *) "newpass_god",
     cf_int_runtime, CA_GOD | CA_IMMORTAL, (int *) &mudconf.newpass_god, 0, CA_IMMORTAL,
     (char *) "Can you newpassword #1 this reboot?\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "no_startup",
     cf_int_runtime, CA_GOD | CA_IMMORTAL, (int *) &mudconf.no_startup, 0, CA_IMMORTAL,
     (char *) "Are startups de-active?\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "noauth_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.special_list, 
     H_NOAUTH, CA_WIZARD,
     (char *) "Specify sites to block AUTH/IDENT lookups."},
    {(char *) "noautoreg_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.access_list,
     H_NOAUTOREG, CA_WIZARD,
     (char *) "Specify sites to block autoregistration."},
    {(char *) "noautoreg_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.autoreg_host, 1000, CA_WIZARD,
     (char *) "Specify site NAMES to block autoregistration."},
    {(char *) "nobroadcast_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.nobroadcast_host, 1000, CA_WIZARD,
     (char *) "This specifies sites by NAME to not MONITOR."},
    {(char *) "nodns_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.special_list,
     H_NODNS, CA_WIZARD,
     (char *) "Specify sites to block dns lookups."},
    {(char *) "noguest_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.access_list,
     H_NOGUEST, CA_WIZARD,
     (char *) "Specify sites to block guest connections."},
    {(char *) "noguest_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.noguest_host, 1000, CA_WIZARD,
     (char *) "Specify site NAMES to block guest connections"},
    {(char *) "nonindxtxt_maxlines",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.nonindxtxt_maxlines, 0, CA_IMMORTAL,
     (char *) "Maximum lines allowed in non-indx .txt file.\r\n"\
              "                             Default: 200   Value: %d"},
    {(char *) "noregist_onwho",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.noregist_onwho, 0, CA_WIZARD,
     (char *) "Are the 'R's snuffed on DOING/WHO?"},
    {(char *) "noshell_prog",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.noshell_prog, 0, CA_PUBLIC,
     (char *) "Can you issue commands outside a @program?"},
    {(char *) "nospam_connect",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.nospam_connect, 0, CA_WIZARD,
     (char *) "Are forbidden sites logged?"},
    {(char *) "notify_recursion_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.ntfy_nest_lim, 0, CA_WIZARD,
     (char *) "Specify recursion limit on notifies.\r\n"\
              "                             Default: 20   Value: %d"},
    {(char *) "notonerr_return",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.notonerr_return, 0, CA_PUBLIC,
     (char *) "Does #-1 return a '0' on boolean logic?"},
    {(char *) "num_guests",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.max_num_guests, 0, CA_WIZARD,
     (char *) "Maximum number of guests allowed.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "oattr_enable_altname",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.oattr_enable_altname, 0, CA_PUBLIC,
     (char *) "Do o-attribs look at alternate names?"},
    {(char *) "oattr_uses_altname",
     cf_string, CA_DISABLED, (int *) mudconf.oattr_uses_altname, 31, CA_WIZARD,
     (char *) "Altname used for o-attributes."},
    {(char *) "offline_reg",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.offline_reg, 0, CA_WIZARD,
     (char *) "Can you autoregister on the connect screen?"},
    {(char *) "online_reg",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.online_reg, 0, CA_WIZARD,
     (char *) "Can you autoregister from a guest?"},
    {(char *) "open_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.opencost, 0, CA_PUBLIC,
     (char *) "Cost to do an @open.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *) "output_database",
     cf_string, CA_DISABLED, (int *) mudconf.outdb, 128, CA_WIZARD,
     (char *) "Name of the output database."},
    {(char *) "output_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.output_limit, 0, CA_IMMORTAL,
     (char *) "Limit on output to your port.\r\n"\
              "                             Default: 16384   Value: %d"},
    {(char *) "page_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.pagecost, 0, CA_PUBLIC,
     (char *) "Cost of a page.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "paranoid_allocate",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.paranoid_alloc, 0, CA_WIZARD,
     (char *) "Double check allocated buffers."},
    {(char *) "paranoid_exit_linking",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.paranoid_exit_linking, 0, CA_PUBLIC,
     (char *) "Improve security on unlinked exits?"},
    {(char *) "parentable_control_lock",
     cf_bool, CA_DISABLED, &mudconf.parent_control, 0, CA_PUBLIC,
     (char *) "Do parents follow ControlLocks?"},
    {(char *) "parent_nest_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.parent_nest_lim, 0, CA_WIZARD,
     (char *) "Maximum nesting allowed on @parents.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "partial_conn",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.partial_conn, 0, CA_PUBLIC,
     (char *) "Partial connects trig master-room @aconnects?"},
    {(char *) "partial_deconn",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.partial_deconn, 0, CA_PUBLIC,
     (char *) "Partial deconn trig master-room @adisconnect?"},
    {(char *) "paycheck",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.paycheck, 0, CA_PUBLIC,
     (char *) "Money player receives daily on connect.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "pcreate_paranoia",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.pcreate_paranoia, 0, CA_WIZARD,
     (char *) "Define DoS create paranoia level (0, 1, 2).\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "pemit_far_players",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.pemit_players, 0, CA_PUBLIC,
     (char *) "Can you @pemit remotely to players?"},
    {(char *) "pemit_any_object",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.pemit_any, 0, CA_PUBLIC,
     (char *) "Can you @pemit to anything remotely?"},
    {(char *) "penn_playercmds",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.penn_playercmds, 0, CA_PUBLIC,
     (char *) "Commands on player work only for player?"},
    {(char *) "penn_switches",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.penn_switches, 0, CA_PUBLIC,
     (char *) "Does switch() understand > and <?"},
    {(char *) "permit_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.access_list, 0, CA_WIZARD,
     (char *) "Site permission for allowing site."},
    {(char *) "player_dark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.player_dark, 0, CA_PUBLIC,
     (char *) "Can players set themselves/puppets dark?"},
    {(char *) "player_flags",
     cf_set_flags, CA_GOD | CA_IMMORTAL, (int *) &mudconf.player_flags, 0, CA_WIZARD,
     (char *) "Default flags used on new players."},
    {(char *) "player_listen",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.player_listen, 0, CA_PUBLIC,
     (char *) "Can players trigger @listen/@hear? DANGEROUS"},
    {(char *) "player_match_own_commands",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.match_mine_pl, 0, CA_PUBLIC,
     (char *) "Players check commands on themselves?"},
    {(char *) "player_match_commands",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.match_pl, 0, CA_PUBLIC,
     (char *) "Commands checked on players?"},
    {(char *) "player_name_spaces",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.name_spaces, 0, CA_PUBLIC,
     (char *) "Spaces allowed in names?"},
    {(char *) "player_queue_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.queuemax, 0, CA_WIZARD,
     (char *) "QUEUE limit for players (Non-Wizards).\r\n"\
              "                             Default: 100   Value: %d"},
    {(char *) "player_quota",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.player_quota, 0, CA_PUBLIC,
     (char *) "Default quota for players.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *) "player_starting_home",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.start_home, 0, CA_WIZARD,
     (char *) "Default home for new players.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "player_starting_room",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.start_room, 0, CA_WIZARD,
     (char *) "Room new players start in.\r\n"\
              "                             Default: 0   Value: %d"},
#ifdef PLUSHELP
    {(char *) "plushelp_file",
     cf_string, CA_DISABLED, (int *) mudconf.plushelp_file, 32, CA_WIZARD,
     (char *) "Name of +help file."},
    {(char *) "plushelp_index",
     cf_string, CA_DISABLED, (int *) mudconf.plushelp_indx, 32, CA_WIZARD,
     (char *) "Name of +help index."},
#endif
    {(char *) "port",
     cf_int, CA_DISABLED, &mudconf.port, 0, CA_WIZARD,
     (char *) "Port the mush runs on.\r\n"\
              "                             Default: 6250   Value: %d"},
    {(char *) "power_access",
     cf_ntab_access, CA_GOD | CA_IMMORTAL, (int *) powers_nametab,
     (pmath2) access_nametab, CA_WIZARD,
     (char *) "Change access permissions of a @power."},
    {(char *) "public_flags",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.pub_flags, 0, CA_WIZARD,
     (char *) "Players can get flags on anything?"},
    {(char *) "queue_active_chunk",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.active_q_chunk, 0, CA_WIZARD,
     (char *) "N/A\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "queue_compatible",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.queue_compatible, 0, CA_WIZARD,
     (char *) "Are QUEUES MUSH compatible to go negative (-1)?"},
    {(char *) "queue_idle_chunk",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.queue_chunk, 0, CA_WIZARD,
     (char *) "N/A\r\n"\
              "                             Default: 3   Value: %d"},
    {(char *) "quiet_look",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.quiet_look, 0, CA_PUBLIC,
     (char *) "Players shown attributes when looking?"},
    {(char *) "quiet_whisper",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.quiet_whisper, 0, CA_PUBLIC,
     (char *) "Are whispers quiet?"},
    {(char *) "quit_file",
     cf_string, CA_DISABLED, (int *) mudconf.quit_file, 32, CA_WIZARD,
     (char *) "File seen when you QUIT/LOGOUT."},
    {(char *) "quotas",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.quotas, 0, CA_PUBLIC,
     (char *) "Are @quotas being used?"},
    {(char *) "read_remote_desc",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.read_rem_desc, 0, CA_PUBLIC,
     (char *) "Can you see @descs on remote things?"},
    {(char *) "read_remote_name",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.read_rem_name, 0, CA_PUBLIC,
     (char *) "Can you see names of remote things?"},
    {(char *) "recycling",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.recycle, 0, CA_WIZARD,
     (char *) "Is recyling dbref#'s currently enabled?"},
    {(char *) "register_create_file",
     cf_string, CA_DISABLED, (int *) mudconf.regf_file, 32, CA_WIZARD,
     (char *) "File used for registering."},
    {(char *) "register_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.access_list,
     H_REGISTRATION, CA_WIZARD,
     (char *) "Site permissions for registration."},
    {(char *) "register_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.register_host, 1000, CA_WIZARD,
     (char *) "Site permissions for NAME registration."},
    {(char *) "regtry_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.regtry_limit, 0, CA_WIZARD,
     (char *) "Times a player can try to register per conn.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *) "restrict_home",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.restrict_home, 0, CA_WIZARD,
     (char *) "Restriction played on 'home' command.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "restrict_sidefx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.restrict_sidefx, 0, CA_WIZARD,
     (char *) "Restrict sideeffect usage.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "retry_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.retry_limit, 0, CA_WIZARD,
     (char *) "Times a player can attempt to connect.\r\n"\
              "                             Default: 3   Value: %d"},
    {(char *) "robot_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.robotcost, 0, CA_PUBLIC,
     (char *) "Cost of creating a @robot.\r\n"\
              "                             Default: 1000   Value: %d"},
    {(char *) "robot_flags",
     cf_set_flags, CA_GOD | CA_IMMORTAL, (int *) &mudconf.robot_flags, 0, CA_WIZARD,
     (char *) "Flags a robot is set with."},
    {(char *) "robot_speech",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.robot_speak, 0, CA_PUBLIC,
     (char *) "Are robots allowed to talk?"},
    {(char *) "room_aconnect",
     cf_bool, CA_GOD | CA_IMMORTAL, (int *) &mudconf.room_aconn, 0, CA_WIZARD,
     (char *) "Should rooms trigger aconnects?"},
    {(char *) "room_adisconnect",
     cf_bool, CA_GOD | CA_IMMORTAL, (int *) &mudconf.room_adconn, 0, CA_WIZARD,
     (char *) "Should rooms trigger adisconnects?"},
    {(char *) "room_flags",
     cf_set_flags, CA_GOD | CA_IMMORTAL, (int *) &mudconf.room_flags, 0, CA_WIZARD,
     (char *) "Default flags for a new room."},
    {(char *) "roomlog_path", 
     cf_string, CA_DISABLED, (int *) mudconf.roomlog_path, 128, CA_WIZARD,
     (char *) "Path where LOGROOM logs are sent."},
    {(char *) "room_quota",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.room_quota, 0, CA_WIZARD,
     (char *) "Ammount of quota each room takes.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *) "rwho_data_port",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.rwho_data_port, 0, CA_WIZARD,
     (char *) "N/A\r\n"\
              "                             Default: 6889   Value: %d"},
    {(char *) "rwho_dump_interval",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.rwho_interval, 0, CA_WIZARD,
     (char *) "N/A\r\n"\
              "                             Default: 241   Value: %d"},
    {(char *) "rwho_host",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.rwho_host, 64, CA_WIZARD,
     (char *) NULL},
    {(char *) "rwho_info_port",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.rwho_info_port, 0, CA_WIZARD,
     (char *) "N/A\r\n"\
              "                             Default: 6888   Value: %d"},
    {(char *) "rwho_password",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.rwho_pass, 32, CA_WIZARD,
     (char *) NULL},
    {(char *) "rwho_transmit",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.rwho_transmit, 0, CA_WIZARD,
     (char *) NULL},
    {(char *) "sacrifice_adjust",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.sacadjust, 0, CA_PUBLIC,
     (char *) "Adjustment applied when sacrificing objects.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "sacrifice_factor",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.sacfactor, 0, CA_PUBLIC,
     (char *) "Numeric factor for sacrificing.\r\n"\
              "                             Default: 5   Value: %d"},
    {(char *) "safe_wipe",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.safe_wipe, 0, CA_PUBLIC,
     (char *) "@wiping SAFE/INDESTRUCTABLE things blocked?"},
    {(char *) "safer_passwords",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.safer_passwords, 0, CA_PUBLIC,
     (char *) "Enforcement of harder passwords?"},
    {(char *) "search_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.searchcost, 0, CA_PUBLIC,
     (char *) "Cost of a @search.\r\n"\
              "                             Default: 100   Value: %d"},
    {(char *) "secure_atruselock",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.secure_atruselock, 0, CA_WIZARD,
     (char *) "Attribute USELOCKS require ATRUSE @toggle?"},
    {(char *) "secure_dark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.secure_dark, 0, CA_WIZARD,
     (char *) "DARK settable by wizards only?"},
    {(char *) "secure_functions",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.secure_functions, 0, CA_WIZARD,
     (char *) "List of functions with added security.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "secure_jumpok",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.secure_jumpok, 0, CA_WIZARD,
     (char *) "Level that the JUMP_OK flag locked down.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "see_owned_dark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.see_own_dark, 0, CA_PUBLIC,
     (char *) "Can you see dark things you control?"},
    {(char *) "showother_altinv",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.showother_altinv, 0, CA_PUBLIC,
     (char *) "Alt inventories shown when you look?"},
    {(char *) "sideeffects",
     cf_sidefx, CA_GOD | CA_IMMORTAL, &mudconf.sideeffects, 0, CA_PUBLIC,
     (char *) "Bitmask for enabling sideeffects.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "sidefx_maxcalls",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.sidefx_maxcalls, 0, CA_PUBLIC,
     (char *) "Maximum sideeffect calls per command.\r\n"\
              "                             Default: 1000 Value: %d"},
    {(char *) "sidefx_returnval",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.sidefx_returnval, 0, CA_PUBLIC,
     (char *) "Do creation sideeffects return values?"},
    {(char *) "signal_action",
     cf_option, CA_DISABLED, &mudconf.sig_action, 
     (pmath2) sigactions_nametab, CA_WIZARD,
     (char *) "Action taken on receiving signals?"},
    {(char *) "space_compress",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.space_compress, 0, CA_PUBLIC,
     (char *) "Spaces compressed?"},
    {(char *) "spam_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.spam_limit, 0, CA_PUBLIC,
     (char *) "Ceiling of commands per minute..\r\n"\
              "                             Default: 60   Value: %d"},
    {(char *) "spam_msg",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.spam_msg, 127, CA_WIZARD,
     (char *) "Message spammer receives when limit reached."},
    {(char *) "spam_objmsg",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.spam_objmsg, 127, CA_WIZARD,
     (char *) "Message spammer receives when object reaches limit."},
    {(char *) "stack_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.stack_limit, 0, CA_PUBLIC,
     (char *) "Ceiling of nested 'command' calls.\r\n"\
              "                             Default: 10000 Value: %d"},
    {(char *) "start_build",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.start_build, 0, CA_WIZARD,
     (char *) "Wanderer flag removed on new players?"},
    {(char *) "starting_money",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.paystart, 0, CA_PUBLIC,
     (char *) "Starting money new player gets.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *) "starting_quota",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.start_quota, 0, CA_PUBLIC,
     (char *) "Starting quota a new player gets.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "status_file",
     cf_string, CA_DISABLED, (int *) mudconf.status_file, 128, CA_WIZARD,
     (char *) "File where @shutdown commands are sent."},
    {(char *) "suspect_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.suspect_list,
     H_SUSPECT, CA_WIZARD,
     (char *) "Site list for specifying suspects."},
    {(char *) "suspect_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.suspect_host, 1000, CA_WIZARD,
     (char *) "Site NAME list for specifying suspects."},
    {(char *) "sweep_dark",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.sweep_dark, 0, CA_PUBLIC,
     (char *) "Can you sweep dark locations?"},
    {(char *) "switch_default_all",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.switch_df_all, 0, CA_PUBLIC,
     (char *) "Does @switch default to @switch/all?"},
    {(char *) "switch_substitutions",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.switch_substitutions, 0, CA_PUBLIC,
     (char *) "Does @switch/switch()/switchall() allow #$?"},
    {(char *) "terse_shows_contents",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.terse_contents, 0, CA_PUBLIC,
     (char *) "Do you see contents with the TERSE flag?"},
    {(char *) "terse_shows_exits",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.terse_exits, 0, CA_PUBLIC,
     (char *) "Do you see exits with the TERSE flag?"},
    {(char *) "terse_shows_move_messages",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.terse_movemsg, 0, CA_PUBLIC,
     (char *) "Does the TERSE flag show movement?"},
    {(char *) "thing_flags",
     cf_set_flags, CA_GOD | CA_IMMORTAL, (int *) &mudconf.thing_flags, 0, CA_WIZARD,
     (char *) "Default flags on new things>"},
    {(char *) "thing_quota",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.thing_quota, 0, CA_WIZARD,
     (char *) "Quota that each thing takes up.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *) "timeslice",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.timeslice, 0, CA_WIZARD,
     (char *) "N/A\r\n"\
              "                             Default: 1000   Value: %d"},
    {(char *) "trace_output_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.trace_limit, 0, CA_WIZARD,
     (char *) "Limit on how much output you can have.\r\n"\
              "                             Default: 200   Value: %d"},
    {(char *) "trace_topdown",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.trace_topdown, 0, CA_PUBLIC,
     (char *) "Does trace go top down, or bottom up?"},
    {(char *) "trust_site",
     cf_site, CA_GOD | CA_IMMORTAL, (int *) &mudstate.suspect_list, 0, CA_WIZARD,
     (char *) "Site used to specify trusted people."},
    {(char *) "uncompress_program",
     cf_string, CA_DISABLED, (int *) mudconf.uncompress, 128, CA_WIZARD,
     (char *) "Program used to uncompress database\r\n"\
              "                                 (default compress)"},
    {(char *) "unowned_safe",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.safe_unowned, 0, CA_PUBLIC,
     (char *) "Things you don't own considered SAFE?"},
    {(char *) "user_attr_access",
     cf_modify_bits, CA_GOD | CA_IMMORTAL, &mudconf.vattr_flags,
     (pmath2) attraccess_nametab, CA_WIZARD,
     (char *) "Default permissions for user-attributes."},
    {(char *) "validate_host", 
     cf_dynstring, CA_GOD | CA_IMMORTAL, (int *) mudconf.validate_host, 1000, CA_WIZARD,
     (char *) "Mail addresses to block from autoreg."},
    {(char *) "vattr_limit_checkwiz",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.vattr_limit_checkwiz, 0, CA_WIZARD,
     (char *) "Are wizards and higher checked for vattr max?"},
    {(char *) "vlimit",
     cf_vint, CA_GOD | CA_IMMORTAL, &mudconf.vlimit, 0, CA_WIZARD,
     (char *) "Maximum user attributes allowed.  Don't touch\r\n"\
              "                             Default: 750   Value: %d"},
    {(char *) "wait_cost",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.waitcost, 0, CA_PUBLIC,
     (char *) "Cost of @waiting.\r\n"\
              "                             Default: 10   Value: %d"},
    {(char *) "wall_cost",
     cf_int, CA_WIZARD, &mudconf.wall_cost, 0, CA_PUBLIC,
     (char *) "Cost of @walling.\r\n"\
              "                             Default: 500   Value: %d"},
    {(char *) "whereis_notify",
     cf_bool, CA_GOD | CA_IMMORTAL, (int *) &mudconf.whereis_notify, 0, CA_WIZARD,
     (char *) "Does @whereis by a cloaked wiz notify you?"},
    {(char *) "who_comment",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.who_comment, 0, CA_PUBLIC,
     (char *) "Does the WHO/DOING display cute messages?"},
    {(char *) "who_default",
     cf_who_bool, CA_GOD | CA_IMMORTAL, &mudconf.who_default, 0, CA_PUBLIC,
     (char *) "Is the WHO/DOING like MUSH/MUX?"},
    {(char *) "who_unfindable",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.who_unfindable, 0, CA_PUBLIC,
     (char *) "Unfindable players hidden from WHO/DOING?"},
    {(char *) "whohost_size",
     cf_int, CA_GOD | CA_IMMORTAL, (int *) &mudconf.whohost_size, 0, CA_WIZARD,
     (char *) "Current size of hosts in WHO/DOING.\r\n"\
              "        -- 0 is unlimited    Default: 0   Value: %d"},
    {(char *) "who_showwiz",
     cf_bool, CA_GOD | CA_IMMORTAL, (int *) &mudconf.who_showwiz, 0, CA_PUBLIC,
     (char *) "Show a '*' by wizards in WHO/DOING?"},
    {(char *) "who_showwiztype",
     cf_bool, CA_GOD | CA_IMMORTAL, (int *) &mudconf.who_showwiztype, 0, CA_PUBLIC,
     (char *) "Show wiz flag by wizards in WHO/DOING?"},
    {(char *) "who_wizlevel",
     cf_int, CA_GOD | CA_IMMORTAL, (int *) &mudconf.who_wizlevel, 0, CA_PUBLIC,
     (char *) "Define level of wiz to show in WHO/DOING.\r\n"\
              "        -- 0 is all wizards  Default: 0   Value: %d"},
    {(char *) "wizmax_vattr_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.wizmax_vattr_limit, 0, CA_WIZARD,
     (char *) "Max times wizard can create new user attribs.\r\n"\
              "                             Default: 1000000 Value: %d"},
    {(char *) "wizmax_dest_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.wizmax_dest_limit, 0, CA_WIZARD,
     (char *) "Max times wizard can @destroy objects/things.\r\n"\
              "                             Default: 100000  Value: %d"},
    {(char *) "wiz_override",
     cf_bool, CA_GOD | CA_IMMORTAL, (int *) &mudconf.wiz_override, 0, CA_WIZARD,
     (char *) "Wizards override locks by default?"},
    {(char *) "wizard_help_file",
     cf_string, CA_DISABLED, (int *) mudconf.whelp_file, 32, CA_WIZARD,
     (char *) "Help file for the wizard help."},
    {(char *) "wizard_help_index",
     cf_string, CA_DISABLED, (int *) mudconf.whelp_indx, 32, CA_WIZARD,
     (char *) "Index file for the wizard help."},
    {(char *) "wizard_motd_file",
     cf_string, CA_DISABLED, (int *) mudconf.wizmotd_file, 32, CA_WIZARD,
     (char *) "Motd file for the wizards."},
    {(char *) "wizard_motd_message",
     cf_string, CA_GOD | CA_IMMORTAL, (int *) mudconf.wizmotd_msg, 1024, CA_WIZARD,
     (char *) "On-line Motd string for the wizards."},
    {(char *) "wizard_queue_limit",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.wizqueuemax, 0, CA_WIZARD,
     (char *) "QUEUE limit for wizards (Architect and higher).\r\n"\
              "                             Default: 1000   Value: %d"},
    {(char *) "wiz_uselock",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.wiz_uselock, 0, CA_WIZARD,
     (char *) "Wizards override uselocks by default?"},
    {(char *) "zone_parents",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.zone_parents, 0, CA_WIZARD,
     (char *) "Zone master attributes are inheritable?"},
    {(char *) "thing_attr_default",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.thing_defobj, 0, CA_WIZARD,
     (char *) "Default defobj for new things.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "exit_attr_default",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.exit_defobj, 0, CA_WIZARD,
     (char *) "Default defobj for new exits.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "player_attr_default",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.player_defobj, 0, CA_WIZARD,
     (char *) "Default defobj for new players.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "room_attr_default",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.room_defobj, 0, CA_WIZARD,
     (char *) "Default defobj for new rooms.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "thing_parent",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.thing_parent, 0, CA_WIZARD,
     (char *) "Default parent for new things.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "exit_parent",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.exit_parent, 0, CA_WIZARD,
     (char *) "Default parent for new exits.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "player_parent",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.player_parent, 0, CA_WIZARD,
     (char *) "Default parent for new players.\r\n"\
              "                             Default: -1   Value: %d"},
    {(char *) "room_parent",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.room_parent, 0, CA_WIZARD,
     (char *) "Default parent for new rooms.\r\n"\
              "                             Default: -1   Value: %d"},
#ifdef REALITY_LEVELS
    {(char *) "reality_level",
     cf_rlevel, CA_DISABLED, (int *)&mudconf, 0, CA_WIZARD,
     (char *) "Defined realitylevels."},
    {(char *) "wiz_always_real",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.wiz_always_real, 0, CA_WIZARD,
     (char *) "Wizards always 'real' in reality?"},
    {(char *) "reality_locks",
     cf_bool, CA_GOD | CA_IMMORTAL, &mudconf.reality_locks, 0, CA_WIZARD,
     (char *) "Is @lock/user a reality lock?"},
    {(char *) "reality_locktype",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.reality_locktype, 0, CA_WIZARD,
     (char *) "Type of lock @lock/user is.\r\n"\
              "                             Default: 0   Value: %d"},
    {(char *)"def_room_rx",
     cf_int, CA_GOD| CA_IMMORTAL, &mudconf.def_room_rx, 0, CA_WIZARD,
     (char *) "Default room RX level.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *)"def_room_tx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.def_room_tx, 0, CA_WIZARD,
     (char *) "Default room TX level.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *)"def_player_rx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.def_player_rx, 0, CA_WIZARD,
     (char *) "Default player RX level.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *)"def_player_tx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.def_player_tx, 0, CA_WIZARD,
     (char *) "Default player TX level.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *)"def_exit_rx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.def_exit_rx, 0, CA_WIZARD,
     (char *) "Default exit RX level.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *)"def_exit_tx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.def_exit_tx, 0, CA_WIZARD,
     (char *) "Default exit TX level.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *)"def_thing_rx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.def_thing_rx, 0, CA_WIZARD,
     (char *) "Default object RX level.\r\n"\
              "                             Default: 1   Value: %d"},
    {(char *)"def_thing_tx",
     cf_int, CA_GOD | CA_IMMORTAL, &mudconf.def_thing_tx, 0, CA_WIZARD,
     (char *) "Default object TX level.\r\n"\
              "                             Default: 1   Value: %d"},
#endif /* REALITY_LEVELS */ 
    {NULL,
     NULL, 0, NULL, 0}};

/* ---------------------------------------------------------------------------
 * cf_set: Set config parameter.
 */

int 
cf_set(char *cp, char *ap, dbref player)
{
    CONF *tp;
    int i;
    char *buff;

    /* Search the config parameter table for the command.
       If we find it, call the handler to parse the argument. */

    for (tp = conftable; tp->pname; tp++) {
	if (!strcmp(tp->pname, cp)) {
	    if (!mudstate.initializing &&
		!check_access(player, tp->flags, 0)) {
		notify(player,
		       "Permission denied.");
		return (-1);
	    }
	    if (!mudstate.initializing) {
		buff = alloc_lbuf("cf_set");
		strcpy(buff, ap);
	    }
	    i = tp->interpreter(tp->loc, ap, tp->extra, player, cp);
            if ( i != 777) {
	       if (!mudstate.initializing) {
		   STARTLOG(LOG_CONFIGMODS, "CFG", "UPDAT")
		       log_name(player);
		   log_text((char *) " entered config directive: ");
		   log_text(cp);
		   log_text((char *) " with args '");
		   log_text(buff);
		   log_text((char *) "'.  Status: ");
		   switch (i) {
		   case 0:
		       log_text((char *) "Success.");
		       break;
		   case 1:
		       log_text((char *) "Partial success.");
		       break;
		   case -1:
		       log_text((char *) "Failure.");
		       break;
                   case -2:
		       log_text((char *) "Success (Resetting).");
		       break;
                   case -3:
		       log_text((char *) "Success (Viewing).");
		       break;
		   default:
		       log_text((char *) "Strange.");
		   }
		   ENDLOG
		       free_lbuf(buff);
	       }
            } else {
               i = 0;
            }
	    return i;
	}
    }

    /* Config directive not found.  Complain about it. */

    cf_log_notfound(player, (char *) "Set", "Config directive", cp);
    return (-1);
}

/* ---------------------------------------------------------------------------
 * do_admin: Command handler to set config params at runtime */

void 
do_admin(dbref player, dbref cause, int extra, char *kw, char *value)
{
    int i, i_tval;

    i_tval = 0;
    if ( strchr(kw, '!') )
       i_tval = 1;
    i = cf_set(kw, value, player);
    if ((i >= 0) && !Quiet(player))
	if ( i_tval )
	   notify(player, "Cleared.");
	else
	   notify(player, "Set.");
    else if (i == -1 && !Quiet(player))
        notify(player, "Failure.");
    else if (i == -2 && !Quiet(player))
        notify(player, "Set. (redefined)");
    return;
}

/* ---------------------------------------------------------------------------
 * cf_read: Read in config parameters from named file
 */

int 
cf_read(char *fn)
{
    int retval;

    mudstate.initializing = 1;
    retval = cf_include(NULL, fn, 0, 0, (char *) "init");
    mudstate.initializing = 0;

    /* Fill in missing DB file names */

    if (!*mudconf.outdb) {
	strcpy(mudconf.outdb, mudconf.indb);
	strcat(mudconf.outdb, ".out");
    }
    if (!*mudconf.crashdb) {
	strcpy(mudconf.crashdb, mudconf.indb);
	strcat(mudconf.crashdb, ".CRASH");
    }
    if (!*mudconf.gdbm) {
	strcpy(mudconf.gdbm, mudconf.indb);
	strcat(mudconf.gdbm, ".gdbm");
    }
    return retval;
}

/* ---------------------------------------------------------------------------
 * list_cf_access: List access to config directives.
 */

void 
list_cf_access(dbref player)
{
    CONF *tp;
    char *buff;

    buff = alloc_mbuf("list_cf_access");
    for (tp = conftable; tp->pname; tp++) {
	if (God(player) || check_access(player, tp->flags, 0)) {
	    sprintf(buff, "%s:", tp->pname);
	    listset_nametab(player, access_nametab, tp->flags,
			    buff, 1);
	}
    }
    free_mbuf(buff);
}

/* Idea taken from TinyMUSH 3.0 */
void list_options_boolean(dbref player, int p_val)
{
   CONF *tp;
   int cntr, t_pages;
   
   cntr = 0; 
   for (tp = conftable; tp->pname; tp++) {
      if (((tp->interpreter == cf_bool)) &&
          (check_access(player, tp->flags2, 0))) {
      cntr++;
      }
   }
   t_pages = cntr / 20 + 1;
   if ( !(cntr % 10) )
      t_pages = t_pages - 1;
   if (p_val > t_pages)
      p_val = t_pages;

   cntr = 0;
   for (tp = conftable; tp->pname; tp++) {
      if (((tp->interpreter == cf_bool)) &&
          (check_access(player, tp->flags2, 0))) {
         if ( (cntr < (20 * (p_val-1))) || 
              (cntr >= (20 * p_val)) ) {
            cntr++;
            continue;
         }
         raw_notify(player, tprintf("%-28.28s %c %s",
                            tp->pname, (*(tp->loc) ? 'Y' : 'N'),
                            (tp->extrach ? tp->extrach : "N/A")), 0);
         cntr++;
      }
   }
   raw_notify(player, tprintf("--- Page %d of %d ---", p_val, t_pages), 0);
} 

void list_options_values(dbref player, int p_val)
{
   CONF *tp;
   int cntr, t_pages;
   static char mybuff[1000];
   
   cntr = 0; 
   for (tp = conftable; tp->pname; tp++) {
      if (((tp->interpreter == cf_int) ||
           (tp->interpreter == cf_int_runtime) ||
           (tp->interpreter == cf_mailint) ||
           (tp->interpreter == cf_vint)) &&
          (check_access(player, tp->flags2, 0))) {
      cntr++;
      }
   }
   t_pages = cntr / 10 + 1;
   if ( !(cntr % 10) )
      t_pages = t_pages - 1;
   if (p_val > t_pages)
      p_val = t_pages;

   cntr = 0;
   memset(mybuff, 0, sizeof(mybuff));
   for (tp = conftable; tp->pname; tp++) {
      if (((tp->interpreter == cf_int) ||
           (tp->interpreter == cf_int_runtime) ||
           (tp->interpreter == cf_mailint) ||
           (tp->interpreter == cf_vint)) &&
          (check_access(player, tp->flags2, 0))) {
         if ( (cntr < (10 * (p_val-1))) || 
              (cntr >= (10 * p_val)) ) {
            cntr++;
            continue;
         }
         sprintf(mybuff, "%-28.28s %.900s", tp->pname, tp->extrach);
         raw_notify(player, tprintf(mybuff, *(tp->loc)), 0);
         cntr++;
      }
   }
   raw_notify(player, tprintf("--- Page %d of %d---", p_val, t_pages), 0);
} 

/*---------------------------------------------------------------------------
 * cf_display: Given a config parameter by name, return its value in some
 * sane fashion.
 */

void cf_display(dbref player, char *param_name, int key, char *buff, char **bufc)
{
    CONF *tp;
    int first, bVerboseSideFx = 0;
    static char tempbuff[LBUF_SIZE/2];
    char *t_pt, *t_buff;

    if ( key || (*param_name == '1') || (*param_name == '0') ) {
       first = 0;
       t_pt = t_buff = alloc_lbuf("cf_display");
       for (tp = conftable; tp->pname; tp++) {
           if (check_access(player, tp->flags2, 0)) {
              if ( first )
                 safe_chr(' ', buff, bufc);
              if ( strlen(buff) > 3900 ) {
                 if (*param_name == '1')
                    break;
                 safe_str(tp->pname, t_buff, &t_pt);
                 safe_chr(' ', t_buff, &t_pt);
              } else {
                 safe_str(tp->pname, buff, bufc);
              }
              first = 1;
           }
       }
       if ( *t_buff )
          notify(player, t_buff);
       free_lbuf(t_buff);
    } else {

       if (stricmp(param_name, "sideeffects_txt") == 0) {
	 param_name[11] = '\0';
	 bVerboseSideFx = 1;
       } 

       for (tp = conftable; tp->pname; tp++) {
           if (!stricmp(tp->pname, param_name)) {
               if (!check_access(player, tp->flags2, 0)) {
                   safe_str("#-1 PERMISSION DENIED", buff, bufc);
                   return;
               }
               if ( (tp->interpreter == cf_int) ||
                    (tp->interpreter == cf_bool) ||
                    (tp->interpreter == cf_who_bool) ||
                    (tp->interpreter == cf_int_runtime) ||
                    (tp->interpreter == cf_mailint) ||
                    (tp->interpreter == cf_vint) ||
		    (tp->interpreter == cf_sidefx && !bVerboseSideFx)) {

                   sprintf(tempbuff, "%d", *(tp->loc));
                   safe_str(tempbuff, buff, bufc);
                   return;
               } else if ( (tp->interpreter == cf_string) ||
                         (tp->interpreter == cf_dynstring) ||
                         (tp->interpreter == cf_dynguest) ||
			 (tp->interpreter == cf_sidefx && bVerboseSideFx)) {
    		   if (tp->interpreter == cf_sidefx) {
		     sideEffectMaskToString(*tp->loc, buff, bufc);
		   } else {
		     safe_str((char *)tp->loc, buff, bufc);
		   }
		 return;
               }
               safe_str("#-1 PERMISSION DENIED", buff, bufc);
               return;
           }
       }
       safe_str("#-1 NOT FOUND", buff, bufc);
   }
}

#ifdef _0_
// Incomplete code - Lensman
//    More complex than I'd first thought :P
CMD_ONE_ARG(dump_config) {

  FILE *pConfFile;
  CONF *pConf;

  if (!Good_obj(player)) {
    return;
  }

  if (!God(player)) {
    notify(player, "Permission Denied.");
  } else if (!message || *messages == '\0') {
    notify(player, "No filename specified");
  } else {
    pConfFile = fopen(message, "w");
    if (!pConfFile) {
      notify(player, "Could not open file for writing.");
    } else {
      fprintf("# RhostMUSH config file.\n");
      fprintf("# Autogenerated by %s at %s.\n", Name(player), ctime(&mudstate.now));
      fprintf("#\n");
      for (pConf = conftable, i = 0 ; pConf[i].pname != NULL ; i++) {
	fprintf("# Param: %s\n#   %s\n%s\t", 
		pConf[i].pname, 
		(!pConf[i].extrach || !*pConf[i].extrach) ? "No description" : pConf[i].extrach, 
		pConf[i].pname);
	switch 
      }
    }
  }
}
#endif

#endif /* STANDALONE */
